1 Allgemeine Einführung in .NET
	1.2 .NET unter die Lupe genommen
		1.2.4 Die »Common Language Specification« (CLS)
			
			Die Common Language Specification (CLS) sind die Richtlinien, die eine Sprache beinhalten muss um eine .NET Sprache zu sein. Sofern eine Programiersprache diese Richtlinien erfüllt, kann z.B. eine Klasse in dieser Sprache in jeder beliebigen anderen .NET basierten Sprache genutzt, erweitert, vererbt etc. werden.
			
			
		1.2.5 Das »Common Type System« (CTS)
			
			Das Common Type System beschreibt in erster Linie die Datentypen von .NET. Man unterscheidet zwischen Wertetypen und Referenztypen. Während Wertetypen auf dem Stack abgelegt werden und eingebaute Typen wie ganzzahlige Typen bzw. Fließkommatypen enthalten, enthalten Referenztypen unter anderem die aus den Klassen erzeugten Objekte. Referenztypen werden auf dem Heap abgelegt. Diese Typen können sogenannte Mitglieder besitzen (Felder, Eigenschaften, Methoden und Ereignisse). Die CTS handhabt außerdem die Sichtbarkeit dieser Mitlgieder.
		
		
		1.2.6 Das .NET Framework
			
			Ein Framework ist eine Art Gerüst in dem Anwendungen entwickelt, kompiliert und ausgeführt werden. Es spiegelt also die Gesamtheit vom Code bis zum ausgeführten Programm wieder.
			
			Die CLS sowie die CTS sind ein Teil dieses Frameworks. Weitere Teile sind die »Common Language Runtime« (CLR) sowie die Klassenbibliothek des .NET.
		
		
		1.2.7 Die »Common Language Runtime« (CLR)
			
			Die Common Language Runtime ist die Laufzeitumgebung des .NET. Dieser Teil des Frameworks ist für die Ausführung der Anwendungen zuständig und bildet damit das Herzstück des Frameworks.
			Die CLR ist kein Programm an sich sondern beschreibt unterschiedliche Dienste die als Bindeglied zwischen dem IL Code und der Hardware zu verstehen ist.
			
			Diese Dienste sind:
			
			-Der Class Loader, um Klassen in die Laufzeitumgebung zu laden
			-Der Type Checker um unzulässige Typkonvertierungen zu unterbinden
			-Der JIT compiler (JITter), um den IL Code zur Laufzeit in nativen Code umzuwandeln, der vom Prozessor ausgeführt werden kann
			-Der Exception Manager, der die Ausnahmebehandlung unterstützt
			-Der Garbage Collector, der eine automatische Speicherbereinigung anstößt sobald Objekte nicht mehr genutzt werden
			-Die Security Engine, die überprüft, ob der User über ausreichende Berechtigung verfügt um den angeforderten Code auszuführen
			-Die Debug Machine zum Debuggen der Anwendung
			-Der Thread Service zum unterstützen multithread-fähiger Anwendungen
			-Der COM Marshaller zur Sicherstellung der Kommunikation mit COM-Komponenten (COM = Component Object Model)
			
		
		1.2.8 Die .NET-Klassenbibliothek
		
			Die .Net-Klassenbibliothek beschreibt die Gesamtheit der in .NET zur Verfügung stehenden Standartklassen. Innerhalb der Klassenbibliothek gibt es die sogenannte Klassenhierarchie, da jede Klasse mit den anderen Klassen innerhalb der Bibliothek in enger Beziehung stehen.
			
			Die Hierarchie hat natürlich auch eine Wurzel. Diese ist die Klasse »Object«. Jede Klasse erbt die Eigenschaften dieser untersten Klasse. Dies ist ein wichtiger Punkt in der Klassenbibliothek, da es zeigt wie diese aufgebaut ist, bzw. wie die Beziehung der Klassen undereinander zu verstehen ist.
		
		
		1.2.9 Das Konzept der Namespaces
			
			Namespaces geben einen Bereich von Klassendefinitionen an, der nach Sinn eingeteilt ist. Sie sind also eine Art Bibliothek bestimmter Klassen (nicht zu verwechseln mit der Klassenbibliothek). Zu beachten ist hierbei, dass sich eine Klasse, die sich innerhalb eines bestimmten Namespaces befindet nicht in der Funktionalität bzw. dessen Möglichkeiten von einer Klasse in einem anderen Namespace unterscheiden muss. Der Namespace ist nur dazu da dem Entwickler eine logische Zusammnfassung bestimmter Klassen zu geben die im gleichen Einsatzgebiet arbeiten.
			Auch die Namspaces sind, wie die Klassenbibliothek, baumartig aufgebaut. Die Wurzel heißt hier »System«. In diesem Namespace ist z.B. die Klasse enthalten, die den Datentyp »int« beschreibt.
			
			
2 Grundlagen der Sprache C#
	2.3 Variablen und Datentypen
		2.3.1 Variablendeklaration
		
			Daten werden in Variablen gespeichert. Diese Variablen stehen für eine bestimmte Adresse im Speicher der für diese Variable reserviert wird. Je nach Typ der Variable wird eine unterschiedlich große Menge an Bytes im Speicher reserviert.
			Der sogenannte Bezeichner gibt der Variablen einen leicht zu merkenden Namen, er ist also quasi ein Synonym eines bestimmten Speicherortes.
			Bevor eine Variable genutzt werden kann muss sie deklariert werden. Dies geschiet in dem man den Datentyp gefolgt von dem Variablenbezeichner angiebt. Abschließend wird, wie nach jeder Anweisung, ein Semikolon gesetzt.
			Die allgemeine Syntax für die Deklaration einer Variablen lautet also:
			
				Datentyp Bezeichner;
			
			Wird der Variablen nach der Deklaration ein Wert zugewiesen spricht man auch von der Initalisierung selbiger.
			
			Zu diesen hier ein Praktisches Beispiel:
			
				Deklaration:
				
				int value;
				
				Initialisierung:
				
				value = 1000;
				
			Die Initialisierung einer Variable kann auch während der Deklaration stattfinden zum Beispiel
			
				int value = 1000;
				
			Eine Variable kann nicht initialisiert werden, wenn sie nicht vorher deklariert wurde. Des Weiteren ist zu beachten, dass eine nicht initialisierte Variable keinen Wert besitzt, auch nicht die 0. Die Auswertung bzw. der Aufruf einer nicht initialisierten Variablen ist demnach nicht möglich.
			
			Es können auch mehrere Variablen des gleichen Typs innerhalb einer Anweisung Deklariert und nach bedarf initialisiert werden.
			
				int a, b = 1, c = 3;
				
				
		2.3.2 Der Variablenbezeichner
			
			Der Variablenbezeiner muss eindeutig sein, darf also nicht den Namen einer bestehenden Klasse, Prozedur, Schlüsselwort oder Objekt erhalten. Außerdem darf er nur aus alphanumerischen Zeichen sowie dem Unterstrich bestehen, wobei der Anfang immer ein Buchstabe sein muss.
			
		2.3.4 Ein- und Ausgabemethoden der Klasse »Console«
			
			Wenn eine Methode aufgerufen werden soll muss der Objekt- bzw. Klassenname gefolgt von einem Punkt und dem Methodennamen eingegeben werden. Es folgt ein Klammernpaar. Die allgemeine Schreibweise um eine Methode aufzurufen lautet also:
			
			Objektname.Methodenname();
			
			Es lassen sich in der Methode Write bzw. WriteLine auch sogenannte Formatausdrücke ausgeben. Diese werden innerhalb des auszugebenden Textes (der in Anführungzeichen geschrieben wird) in geschweiften Klammern geschrieben und enthält mindestens eine Zahl. Hinter dem auszugebenden Text stehen dann kommagetrennt die Variablen, die anstelle der Formatausdrücke stehen sollen. Hierzu ein Beispiel:
			
				string text1 = "C#";
				string text2 = "Spaß";
				Console.WriteLinw("{0] macht {1}", text1, text2);
			
			Möchte man, dass der Formatausdruck eine bestimmte Breite bekommt, kann man selbige als Wert, der kommagetrennt vom Zählerwert geschrieben wird, übergeben. Beispiel:
			
				Console.WriteLinw("{0,3] macht {1,20}", text1, text2);
				
			Der angegebene Wert fügt der der Ausgabe gegebenenfalls Leerzeichen hinzu. Es kann auch eine negative Zahl genommen werden, dies sorgt dafür, dass der Wert Linksbündig geschrieben wird und dahinter gegebenenfalls die Leerzeichen angehängt werden.
			
			
		2.3.5 Die einfachen Datentypen
			
			Folgend eine Auflistung der elementaren Datentypen von .NET und deren Alias in C#:

			
				.NET		C#			CLS Konform		Wertebereich
				
				Byte		Byte		ja				0 ... 255
				SByte		sbyte		nein			–128 ... 127
				Int16		short		ja				–2^15 ... 2^15 –1
				UInt16		ushort		nein			0 ... 65535
				Int32		int			ja				–2^31 ... 2^31 –1
				UInt32		Uint		nein			0 ... 2^32 –1
				Int64		long		ja				–2^63 ... 2^63 –1
				UInt64		Ulong		nein			0 ... 2^64 –1
				Single		float		ja				1,4 * 10^–45 bis 3,4 * 10^38
				Double		double		ja				5,0 * 10^–324 bis 1,7 * 10^308
				Decimal		decimal		ja				
				Char		char		ja				Unicode-Zeichen zwischen 0 und 65535
				String		string		ja				ca. 2^31 Unicode-Zeichen
				Boolean		bool		ja				true oder false
				Object		object		ja				Eine Variable vom Typ Object kann jeden anderen Datentyp enthalten, ist also universell.
				
			Weisen wir einer Variablen des Datentyps float eine Fließkommazahl zu, so kommt es zu einem Kompilierfehler. Dies ist dem Fakt geschuldet, dass vor dem Zuweisen eines Wertes an eine Variable die zuzuweisende Zahl zwischengespeichert werden muss. In der Laufzeitumgebung wird einer Fließkommazahl jedoch standartmäßig der Typ double zugewiesen. Dies führt dazu, dass man versucht, eine Zahl des Typs double in einer Variable des Typs float zuzuweisen. Da der Wertebereich von double jedoch Größer ist, als der von float, kommt es zu diesem Fehler. Man kann sich abhilfe schaffen indem man der zu speichernden Zahl das Suffix F oder f (für float) zuweist. Dies ermöglicht das Speichern der Zahl in einer float Variablen, gemäß dem Fall, die Zahl befindet sich innerhalb des Wertebereichs eines float.
			
			Weitere Suffixe sind D bzw. d für double und M bzw. m für decimal.
			
			Die unterschiedlichen Datentypen für Fließkommazahlen unterscheiden sich, neben dem Fakt, dass sie unterschiedlich große Speicherbreiche reserbieren, damit ligischerweise auch in der Genauigkeit.
			
			Der Datentyp Char speichert genau ein Zeichen aus dem Unicode Zeichensatz aufnehmen. Sie werden in einfache Anführungszeichen gesetzt.
			
			Der Datentyp string speichert Zeichenketten. Diese werden in normalen Anführungszeichen gesetzt.
			
			Variablen vom Typ bool können nur true oder false als Wert erhalten wobei false der standartwert ist.
			
			Variablen vom Typ object sind am allgemeinsten. Diese können jeden beliebigen Datentyp annehmen. So ist folgender Code ohne weiteres ausführbar:
			
				object universal;
				universal = 5;
				Console.WriteLine(universal);
				universal = "Hallo Welt.";
				Console.WriteLine(universal);
				
			Der Beweis, dass in C# alles als object angesehen wird (sogar die elementaren Datentypen) sieht man, wenn man z.B. Int16. eingibt. Hierbei ist wie oben beschrieben der Punkt ganz wichtig. Es zeigt sich in Visual Studio ein Dropdownmenü mit allen Methoden die im Objekt Int16 enthalten sind.
			
		
		2.3.6 Typenkonvertierung
		
			Es ist prinzipiell möglich einen Datentyp in einen anderen Datentyp umzuwandeln. Man unterscheidet generell zwischen impliziter und expliziter Konvertierung.
			
				Die implizite Konvertierung:
				
					Die implizite Konvertierung wird vom Compiler automatisch genutzt.
					Bei der impliziten Konvertierung kann ein (Zahlen-) Datentyp nur dann in einen anderen konvertiert werden, sofern der Zieldatentyp einen größeren Wertebereich aufweist als der Ausgangsdatentyp oder anders ausgedrückt:
			
						byte --> short --> int --> long und ab da an entweder --> float --> double oder --> decimal
				
						Eine Konvertierung kann immer nur in Pfeilrichtung durchgeführt werden, gegen die Pfeilrichtung wäre die Konvertierung explizit.
						
						Zu beachten ist hierbei, dass entweder von einem Datentyp mit einem kleineren Wertebereich in float bzw. double konvertiert werden kann oder in decimal. Eine implizite konvertierung von z.B. float in decimal ist nicht möglich.
						Ausnahmen bilden hier die Datentypen bool, string, char und object.
						Ein bool bzw. ein string können implizit in keinen anderen Datentyp konvertiert werden. Ein char kann, mit Ausnahme von byte und short in jeden anderen Datentyp konvertiert werden.
						Zu Konvertierung einer Variablen des Typs object kommen wir später.
						
				Die explizite Konvertierung
				
					Unter expliziter konvertierung versteht man die ausdrückliche Anweisung an den Compiler einen bestimmten Datentyp in einen anderen umzuwandeln.
					Die allgemeine Syntax lautet:
					
						(Zieldatentyp)Ausdruck
					
					In diesem Fall nennt man die runden Klammern Typkonvertierungoperator. Mit der expliziten Konvertierung ist z.B. auch eine Konvertierung vom Typ float in decimal möglich, genau wie von z.B. byte in char.
					
					Der expliziten Konvertierung mit dem Typkonvertierungoperator sind jedoch Grenzen gesetzt. Ein bool Datentyp kann auf diese Weise auch nicht in einen anderen konvertiert werden. Hierzu wird die Klasse »Convert« verwendet.
					
					Diese Klasse enthält folgende Methoden:
					
						ToBoolean(Ausdruck)
						ToByte(Ausdruck)
						ToChar(Ausdruck)
						ToDecimal(Ausdruck)
						ToDouble(Ausdruck)
						ToInt16(Ausdruck)
						ToInt32(Ausdruck)
						ToInt64(Ausdruck)
						ToSByte(Ausdruck)
						ToSingle(Ausdruck)
						ToString(Ausdruck)
						ToUInt16(Ausdruck)
						ToUInt32(Ausdruck)
						ToUInt64(Ausdruck)
						
					Der Vorteil der Convert Methode ist, dass damit Konvertierungen möglich sind, die mit dem Typkonvertierungsoperator nicht möglich sind. Allerdings kann Convert nur in elementare Datentypen konvertieren. Es kann beim Typenkonvertierungoperator dazu kommen, dass ein Überlauf einfach ignoriert und abgeschnitten wird, wenn wir von einem Datentyp mit einem höheren Wertebereich in einen Datentyp mit kleinerem Wertebereich konvertieren, die zu konvertierende Zahl jedoch den Wertebereich des "kleineren" Datentypes übersteigt. Dies kann mit der Convert Methode nicht geschehen.
					
					
	2.4 Operatoren
		
		Ein sogenannter Ausdruck ist die kleinste ausführbare Einheit eines Programms und setzt mindestens einen Operator voraus. Ein Audruck besteht immer aus mindestens einem Operanden und mindestens einem Operator. Im Beispiel
		
			value = 22;
			
		sind "value" sowie die Zahl 22 die Operanden während das = den Operator dastellt.
		Es wird zwischen folgenden Operatoren unterschieden:
		
			-arithmetische Operatoren
			-Vergleichsoperatoren
			-logische Operatoren
			-bitweise Operatoren
			-Zuweisungsoperatoren
			-sonstige Operatoren
			
		2.4.1 Arithmetische Operatoren
			
			Unter arithmetischen Operatoren versteht man in der Programmierung neben den standartmäßigen ( + - * / ) auch die Modulo Operation ( % ) sowie die schnellschreibweisen ++ (plus eins) und -- (minus eins).
			
			Die arithmetischen Operatoren + und - haben zusätzlich noch den Sinn einer Variablen ein Vorzeichen zuzuweisen.
			Zu beachten ist, dass der Operator ++ bzw. -- den Wert einer Variablen abhänig von der Positionierung auf unterschiedliche Weise verändert. Hierzu folgendes Beispiel:
			
				int x = 5;
				int y = x++;
				
				In diesem Beispiel wird der Variablen x der Wert 5 zugewiesen. Im nächsten Schritt wird der Variablen y als erstes der Wert der Variablen x (also 5) zugewiesen und dann der Wert von x um eins erhöht. Die Variable x enthält nach der Deklaration der Variable y also den Wert 6, die Variable y hingegen den Wert 5.
				
				int a = 5;
				int b = ++a;
				
				In diesem Beispiel verhällt es sich anders. Im ersten Schritt wird der Variablen a der Wert 5 zugeordnet und im zweiten als erstes der Wert der Variable a um eins erhöht und erst dann der Variablen b der Wert von a zugewiesen. Faktisch bedeutet dies, dass a als auch b nach der Deklaration der Variablen b den Wert 6 enthalten.
				
			Weiterhin ist bei der Division zu beachten, dass auch hier das Problem der Zwischenspeicherung (aus dem Kapitel 2.3.5) auftritt, wenn wir zwei ganzzahlige Werte miteinander dividieren, die eine Fließkommazahl als Ergebnis haben. Dies ist wie gesagt dem Fakt der Zwischenspeicherung geschuldet. Hierzu ein Beispiel:
			
				double value = 3/4;
				Console.WriteLine(value);
				
				Bevor die Zahl 3 nun durch 4 dividiert wird, werden die beiden Werte zwischengespeichert. Hierbei geht die Laufzeitumgebung natürlich davon aus, dass es sich bei den Zahlen um integer Zahlen handelt. Da bei einer integer jedoch die Nachkommastellen abgeschnitten werden, kommt das Ergebnis 0 dabei heraus. Da wir jedoch wissen, dass die Laufzeitumgebung das Ergebnis immer implizit in den höheren der beiden Datentypen konvertiert, können wir diesen Fehler jedoch leicht umgehen.
				
				double value = 3.0/4;
				Console.WriteLine(value);
				
				Dies ergibt das richtige Ergebnis, da wir eine Zahl vom Datentyp double (da Fließkommazahlen in der Laufzeitumgebung bekanntermaßen immer als double gespeichert werden) in die Gleichung mit einbringen und dadurch als Ergebnis eine Variable des höheren Datentyps double erhalten.
			
			
		2.4.2 Vergleichsoperatoren
		
			Vergleichsoperatoren vergleichen zwei Ausdrücke miteinander. Das Ergebnis eines solchen Vergleichs ist immer ein boolscher Wert also entweder true oder false. Es kann hierbei auf Gleichheit, Ungleichheit oder auch größer als bzw. kleiner als verglichen werden. Folgend alle Syntaktischen Vergleichsoperatoren und deren Bedeutung:
			
				Operator		Bedeutung
				
				a == b			Gibt true zurück, wenn Ausdruck a Ausdruck b entspricht.
				a != b			Gibt true zurück, wenn Ausdruck a ungleich Ausdruck b ist.
				a > b			Gibt true zurück, wenn Ausdruck a größer als Ausdruck b ist.
				a < b			Gibt true zurück, wenn Ausdruck a kleiner als Ausdruck b ist.
				a <= b			Gibt true zurück, wenn Ausdruck a kleiner oder gleich b ist.
				a >= b			Gibt true zurück, wenn Ausdruck a größer oder gleich b ist.
				
				Zu beachten ist hier, dass beim Vergleich auf Gleichheit ( == ) von zwei Strings auf Groß- und Kleinschreibung geachtet wird. Der String "Hallo" ist damit nicht gleich dem String "hallo".
				
			
		2.4.3 Logische Operatoren
		
			Logische Operatoren geben ebenfalls einen boolschen Wert zurück. Die in C# zur verfügung stehenden logischen Operatoren sind:
			
				Operator		Bedeutung							Beispiel
				
				!				Unärer Negationsoperator			!a ist true, wenn a false ist. Der Negationsoperator kehrt den Wahrheitswert eines Ausdrucks prinzipiell um.
				&				And-Operator (1. Variante)			a & b ergibt true, sofern Ausdruck a und Ausdruck b true sind. Hierbei werden beide Ausdrücke ausgewertet.
				|				Or-Operator (1. Variante)			a | b ist true, sofern a true ist oder b true ist oder beide true sind. Es werden beide Ausdrücke berücksichtigt.
				^				Xor-Operator						a ^ b ist true, wenn entweder a oder b true ist, sind beide true ist das Ergebnis des Vergleiches false.
				&&				And-Operator (2. Variante)			a && b ist true, wenn sowohl a als auch b true sind. Sollte a bereits false sein, kommt b garnicht erst zur Ausführung.
				||				Or-Operator (2. Variante)			a || b ist true, wenn a oder b oder beide true sind. Ist a bereits true, kommt b garnicht erst zur Ausführung.
				
			Als Wahrheitstabelle sieht das ganze dann folgendermaßen aus:
				
				a		b			And		Or		Xor
				
				true	true		true	true	false
				false	true		false	true	true
				true	false		false	true	true
				false	false		false	false	false
				
			Logische Operatoren können auch mehrfach in einer Anweisung vorkommen um z.B. komplexere Kontrollstrukturen zu erzeugen:
			
				if(x < 5 || y > 20)
				Console.WriteLine("Bedingung ist erfüllt");
				
			
		2.4.4 Bitweise Operatoren
		
			Bitweise Operatoren sind für den Zugriff und die Manipulation der einzelnen Bits eines Operanden. Folgend die zur Verfügung stehenden Operatoren:
			
				Operator		Bedeutung
				
				~				Invertiert jedes Bit des Ausdrucks (Einerkomplement)
				|				aus x|y resultiert ein Wert der durch die Veroderung der Bits der beiden Variablen entsteht
				&				aus x&y resultiert ein Wert der durch die Verundung der Bits der beiden Variablen entsteht
				^				aus x^y resultiert ein Wert der durch die Xor Verknüfung der Bits der beiden Variablen entsteht
				<<				dieser Operator verschiebt die Bits aus x um die Anzahl Stellen nach link, die in y gespeichert sind
				>>				dieser Operator verschiebt die Bits aus x um die Anzahl Stellen nach rechts, die in y gepseichert sind
				
				Hierzu folgende Beispiele:
				
				a = 13 & 5;
				Console.WriteLine(a);
				
				Die Bitweise Darstellung der Zahlen lautet:
				
				13 	= 0000 0000 0000 1101
				5 	= 0000 0000 0000 0101
				
				Durch die Verundung dieser beiden Literale ergibt sich
				
				a	= 0000 0000 0000 0101
				
			-----	
				
				int a = 71 | 49;
				Console.WriteLine(a);
				
				Die Bitweise Darstellung der Zahlen lautet:
				
				71	= 0000 0000 0100 0111
				49	= 0000 0000 0011 0001
				
				Durch die Veroderung dieser beiden Literale ergibt sich
				
				a	= 0000 0000 0111 0111
				
			-----
			
				int a = 53;
				a = a ^ 22;
				Console.WriteLine(a);
					
				Die Bitweise Darstellung der Zahlen lautet:
					
				53	= 0000 0000 0011 0101
				22	= 0000 0000 0001 0110
					
				Durch die Xor Verknüpfung dieser beiden Literale ergibt sich
					
				a	= 0000 0000 0010 0011
					
			-----
			
				c = 37 << 2;
				Console.WriteLine("dezimal    : {0}",c);
				
				Bei dem << bzw. >> Operator verschieben wir die Bits von c in diesem Beispiel um 2. Daraus folgt für <<:
				
				37	= 0000 0000 0010 0101
				
				c	= 0000 0000 1001 0100
				
				und für >>:
				
				c	= 0000 0000 0000 1001
				
				
		2.4.5 Zuweisungsoperatoren
		
			Neben dem Zuweisungsoperator = gibt es noch andere, wobei diese nur als Kurzschreibweise für Rechenoperationen dienen wobei x die empfangende Variable ist. Diese sind:
			
			Operator		Beschreibung
			
			=				x = y weißt x den Wert von y zu
			+=				x += y weißt x den Wert von x + y zu
			-=				x -= y weißt x den Wert von x - y zu
			*=				x += y weißt x den Wert von x * y zu
			/=				x /= y weißt x den Wert von x / y zu
			%=				x %= y weißt x den Wert von x % y zu
			&=				x &= y weißt x den Wert von x & y zu
			|=				x |= y weißt x den Wert von x | y zu
			^=				x ^= y weißt x den Wert von x ^ y zu
			<<=				x <<= y weißt x den Wert von x << y zu
			>>=				x >>= y weißt x den Wert von x >> y zu
			
		
		2.4.6 Stringverkettungen
		
			Sobald einer der genutzten Operanden vom Typ string ist sorgt der + Operator für eine Zeichenverkettung. Das Ergebnis ist immer ein string, was faktisch bedeutet, dass ein Operant der nicht vom Typ string ist implizit in diesen konvertiert wird.
			
		
		2.4.7 Sonstige Operatoren
		
			Operator			Beschreibung
			
			.					Der Punktoperator wird für den Zugriff auf Eigenschaften oder Methoden von Klassen 	verwendet
			[]					Der [] Operator wird für Arrays, Indexer und Attribute verwendet
			()					Dieser Operator wird entweder zur Bestimmung der Reihenfolge von Operationen oder zur Typkonvertierung verwendet
			?:					Dies ist die Kurzschreibweise einer if Anweisung
			new					Dient zur Instanziierung einer Klasse
			is					Prüft den Laufzeittyp eines Objekts mit einem angegebenen Typ
			typeof				Ruft das System.Type Objekt für einen Typ ab
			checked/unchecked	Steuert die Reaktion der Laufzeitumgebung bei einem arithmetischen Überlauf
			
			
	2.5 Datenfelder (Arrays)
		2.5.1 Die Deklaration und initialisierung eines Arrays
		
				int [] elements;
				
			Initialisiert ein array das Werte vom Typ int enthalten wird. Das array an sich wird durch die eckigen Klammern erzeugt. Danach folgt der Beszeichner des Arrays. Da ein Array wie ein Objekt behandelt wird, wird dieses wie folgt initialisiert:
			
				elements = new int [3];
				
				Auch hier ist es möglich wie bei Variablen die Deaklaration mit der Initialisierung zu kombinieren. Hierzu folgende Beispiele:
				
				int [] elements = new int [3];
				
				Dieses bietet sich immer dann an, wenn zum Zeitpunkt der Deklaration schon feststeht welche Größe das Array haben soll.
				
				Ist zum Zeitpunkt der Deklaration schon klar, welche Werte im Array gespeichert werden sollen bietet sich folgende Schreibweise an:
				
				int [] elements = new int [4] {2, 54, 5, 23};
				
				In diesem Fall kann der Inhalt der eckigen Klammer auch leer gelassen werden, da anhand der vergebenen Werte dieser automatisch erstellt wird.
				
				Die kürzeste Schreibweise wäre:
				
				int [] elements = {32, 5, 76, 2};
				
			Entscheidet man sich dafür Werte anzugeben die gespeichert werden sollen und gibt außerdem die Gesamtanzahl der Werte des Arrays an ist zu beachten, dass alle angegebenen Werte angegeben werden müssen. Definieren wir also ein Array mit 4 Einträgen und geben einen Wert zur speicherung an, müssen die 3 anderen auch angegeben werden.
			
			
		2.5.2 Der Zugriff auf Array Elemente
			
			Gegeben sei folgendes Array:
			
				int [] elements = new int [3];
				
			Da dieses deklariert und intialisiert wurde, stehen schon Einträge in den Speicherplätzen, da jeder Speicherplatz eines Arrays mit 0 vorinitialisiert wird. Wollen wir den einzelnen Speicherbereichen nun Werte zuweisen geschieht dies durch die folgende Syntax:
			
				elements[0] = 55;
				
			Dementsprechend greifen wir mit
			
				int value = elements[0];
				
			auf den Wert an der ersten Stelle des Arrays (55) zu und speichern diesen in der Variable value.
			
			
		2.5.3 Mehrdimensionale Arrays
		
			Stellt man sich ein eindimensionales Array vor, so denkt man an eine Rheie von Werten auf einer Geraden. Ein Zweidimensionales Array entspricht dann einer Matrix mit Reihen und Spalten. Ein Array kann theoretisch unendlich viele Dimensionen haben.
			
			Die folgende Syntax definiert ein zweidimensionales Array:
			
				int [,] elements = int [3,2] {{2, 3},{1, 5},{25, 57}};
				
				Wie wir sehen wird die Zuweisung von Literalen komplexer mit Erhöhung der Dimensionen. Es ist hierbei wichtig, eine gute Formatierung des Codes einzuführen. Hierzu ein dreidimensionales Array:
				
				int [,,] elements = {
										{{1, 3, 15, 6}, {4, 9,56, 4}, {7, 30, 46, 2}}
										{{3, 65, 12, 2}, {45, 6, 89, 3}, {2, 90, 46, 12}}
									};
				
				Dieses Beispiel entspricht einem Array elements[2,3,4]. Wollen wir nun auf die Elemente innerhalb der Arrays zugreifen, so müssen wir jede Dimension des Arrays angeben. Das führt dazu, dass
				
					Console.WriteLine(elements[1,1,1]);
					
				die Zahl 6 ausgiebt.
				
		2.5.7 Verzweigte Arrays
			
			Neben den unterschiedlichen Dimensionen eines Arrays gibt es auch die Möglichkeit ein Array in einem anderen Array zu Speichern. Dies wird dann als verzweigtes Array bezeichent. Die Deklaration eines Verzweigten Arrays ist etwas komplizierter und kann z.B. folgendermaßen aussehen:
			
				int [][] myArr = new int [4][];

				Diese Deklaration sagt aus, dass wir es hier mit einem Array zu tun haben, welches 4 Einträge hat, die ihrerseits wieder Arrays sind. Jedes Array innerhalb des myArr Arrays muss für sich initialisiert werden. Dieses könnte wie folgt aussehen:
				
				myArr[0] = new int [3];
				myArr[1] = new int [7];
				myArr[2] = new int [2];
				myArr[3] = new int [4];
				
				Sind die Werte bekannt, kann auch gleich literalinitialisiert werden:
				
				myArray[0] = new int[3]{1,2,3};
				myArray[1] = new int[7]{1,2,3,4,5,6,7};
				myArray[2] = new int[2]{1,2};
				myArray[3] = new int[4]{1,2,3,4};
				
			Bei Zugriff auf verzweigte Arrays ist zu beachten, dass als erstes das Unterarray anzugeben ist und dann der Index desselben Unterarray auf den zugegriffen werden soll:
			
				Console.WriteLine(myArr[3][3]);
				
				Hiermit würde für unser obiges Beispiel die Zahl 4 ausgegeben werden.
				
			Verzweigte Arrays können auch mehrdimensional sein. Hierzu ist folgende Syntax zu verwenden:
			
				int [][,] myArr = new int [2][,];
				
				Zu erkennen ist hier, dass das erste eckige Klammernpaar für die Anzahl der Arrays steht und das zweite für die Dimensionen.
				
	
	2.6 Konsolenstrukturen
		2.6.1  Die »if«-Anweisung
			
			Die allgemeine Syntax einer if Anweisung lautet
			
				if(Bedingung){
					Anweisung
				}
				else{
				Anweisung
				}
				
			Bei der if Anweisung handelt es sich um eine simple Fallunterscheidung. Als Bedingung können vergleichs als auch logische Operatoren eingesetzt werden, da die Bedingung immer einen boolschen Wert zurückgibt.
			
			If Anweisungen lassen sich beliebig oft schachteln um komplexere Fallunterscheidungen durchführen zu können. Dies stellt uns jedoch vor ein Problem.
			
				Console.Write("Geben Sie eine Zahl zwischen 0 und 9 ein: ");
				int zahl = Convert.ToInt32(Console.ReadLine());
				if(zahl >= 0 && zahl <= 9)
				if(zahl <= 5)
				Console.Write("Die Zahl ist 0,1,2,3,4 oder 5");
				else 
				Console.Write("Die Zahl ist unzulässig.");
				
				Da wir in diesem Beispiel ohne Anweiungsblöcke arbeiten kommen wir zu einem logischen Fehler. Da das else optional ist und nur in der äußeren Schleife vorkommen soll entsteht hier ein Fehler, da das else hierbei an das innere if gebunden ist. Ein else ist immer an das nächstgelegene if gebunden. Aus diesem Grund ist es wichtig Anweisungblöcke zu verwenden.
				
			Es ist möglich eine andere Schreibweise der if Anweisung zu nutzen. Hierbei handelt es sich um folgende allgemeine Syntax:
			
				<Variable> = <Bedingung> ? <Wert1> : <Wert2>
				
				Wie zu erkennen ist, spart diese Schreibweise zwar Platz, ist aufgrund ihrer nur schwer zu formatierenden Syntax extrem unübersichtlich und eignet sich ausschließlich für sehr kurze Fallunterscheidungen in der einer Variablen gleich ein Wert zugewiesen werden soll. Rein technisch ist auch hier die verschachtelung möglich, aufgrund besagter Unübersichtlichkeit ist jedoch auf jeden fall davon abzuraten.
				
		2.6.2 Das »switch«-Statement
		
			Das switch Statement läuft änlich wie das if ab. Hierbei wird zu einem nach dem switch stehenden Ausdruck eine Fallunterscheidung in Konstanten, sogenannten cases, unterschieden. Der Compiler prüft einen case nach dem anderen und führt diesen durch, sobald die Konstante erfüllt ist. Die allgemeine Syntax lautet:

				switch(Ausdruck) {
					case Konstante1 :

					// Anweisungen

					Sprunganweisung;
					case Konstante2 :

					// Anweisungen

					Sprunganweisung;
					...
					[default:

					// Anweisungen

					Sprunganweisung;]
				}
				Bei der Sprunganweisung handelt es sich entweder um die Anweisung break, welche die switch Fallunterscheidung abbricht oder goto welches einen Sprung von einem case in einer anderen erlaubt.
				
			Die goto Anweisung kann auch außerhalb eines switch statements genutzt werden, sollte allgemein aber vermieden werden, da dies als schlechter Programmierstil angesehen wird.
			Die allgemeine goto Anweisung die auf eine sogenannte Marke verweist sieht folgendermaßen aus:
			
				goto Markenbezeichner;
				
				[...]
				
				Markenbezeichner:
				
				Wie zu erkennen ist, wird nach der Marke auf die gesprungen wird ein Doppelpunkt geschrieben und der jeweils darauffolgende Code als nächstes ausgeführt.
				
	2.7 Programmschleifen
		2.7.1 Die »for«-Schleife
			
			Die for Schleife wird meist dann eingesetzt wenn klar ist, wie oft die durchzuführende Anweisung auszuführen ist. Die allgemeine Syntax einer for Schleife sieht folgendermaßen aus:
			
				for(Initialisierungsausdruck; Bedingungsausdruck; Reinitialisierungsausdruck){
				
				//Anweisung
				
				}
				
				Wie zu sehen ist, besteht eine Schleife aus zwei Teilen. Der obere Teil wird Schleifenkopf, der Anweisungsblock hingegen Schleifenkörper genannt. Der Schleifenkopf wiederum besteht aus drei Teilen. Der initialisierung einer Zählervariablen (dies wird nur beim ersten Aufruf der Schleife gebraucht), dem Bedingungsausdruck (dieser wird vor jeder Durchführung des Schleifenkörpers geprüft) und dem Reinitialisierungsausdruck (dies ist der Wert um den die Zählervariable verändert werden soll. Dieser Wert wird nach jedem Durchlauf der Schleife durchgeführt).
				
			Es ist wie bei der if Anweisung auch bei Schleifen im allgemeinen möglich diese zu verschachteln. 
			
			Durch die break Anweisung ist es uns wie innerhalb des switch Statements möglich die Schleife vorzeitig zu beenden. Die Anweisung continue gibt uns die Möglichkeit einen Anweisungsblock innerhalb einer Schleife zu beenden ohne jedoch die Schleife selbst zu beenden. Sobald ein continue erreich wurde, wird der Rest eines Anweisungsblockes zwar ignoriert, jedoch wird die Steuerung an den Schleifenkopf übergeben.
			
		2.7.2  Die »foreach«-Schleife
		
			Die foreach Schleife ist eine Weitere Methode um mit Arrays zu arbeiten. Die allgemeine Syntax dieser Schleife lautet:
			
			foreach(Dateityp Bezeichner in Arraybezeichner){
			
			}
			
			Wie wir sehen ist in dieser Schleife keine Initialisierung eines Zählers nötig, da wir mit dem Bezeichner eine Variable festlegen, die jedes Element im angegebenen Array durchlaufen wird. Wichtig hierbei ist außerdem, dass die Angabe des Datentyps vor dem Variablenbezeichner Pflicht ist.
			
		2.7.3  Die »do«- und die »while«-Schleife
		
			Die while Schleife wird immer dann benutzt, wenn erst zur Laufzeit feststeht wie oft diese durchlaufen werden soll. Die allgemeine Syntax einer while Schleife lautet:
			
				while(Bedingung){
				
				//Anweisung
				}
				
				Wie wir sehen gibt es innerhalb des Kopfes dieser Schleife kein Abruckkriterium was bedeutet, dass wir innerhalb des Anweisungsblockes einen Mechanismus einbauen müssen, der diese Aufgabe übernimmt.
			
			Auch in dieser Schleifenart haben wir die Möglichkeit mit break, oder continue die Schleife entweder ganz zu beenden bzw. vorzeitig die Steuerung an den Kopf der Schleife zu übergeben. Es ist zu beachten, dass der Anweisungsblock der Schleife nur solange durchgeführt wird, wie die Bedingung den Wert true zurückgibt. Ist beim ersten Aufruf der Schleife die Bedingung nich true wird die darin enthaltene Anweisung nie ausgeführt.
			
			Bei der do Schleife verhällt es sich etwas anders. Diese Schreibt die Anweisung an die erste Stelle und prüft erst im Nachhinein ob die die Bedingung noch gegeben ist. Dies sorgt dafür, dass der Anweisungsblock bei einer do Schleife auf jeden Fall mindestens einmal durchlaufen wird. Die allgemeine Syntax einer do Schleife lautet:
			
				do{
				
					//Anweisung
					
				}
				while(Bedingung);
				
3 Das Klassendesign
	3.1 Einführung in die Objektorientierung
		
		Eine Klasse ist wie ein Bauplan zu verstehen. Sie dient als Vorlage. Ein Objekt ist ein Element welches etwas konkretes durchführen kann, es spiegelt sozusagen das fertige Produkt geschaffen aus der Klasse wieder. Ein Objekt hat charakteristische Merkmale die als Eigenschaften bezeichnet werden. 
		Wie im Fall von Variablen ist auch bei der Deklaration eines Objektes die Angabe des Datentyps zwingend erforderlich. Hierbei ist zu beachten, dass eine Klasse immer als Beschreibung eines Datentyps anzusehen ist. Bei einer Klasse namens Person können wir das Person-Objekt Peter also wie folgt definieren:
		
			//Definition der Klasse
			class Person{
			
				public string Name;
				public int Alter;
				
				public void Laufen();
			
			}
			
			//Deklaration und Initialisierung des Objekts vom Typ Person
			Person peter = new Person();
			
			Wie wir hier sehen können sind in der Klasse Person unterschiedliche Dinge enthalten. Name und Alter sind Eigenschaften die genutzt werden können und die man als Felder bezeichnet. Laufen() ist eine Methode innerhalb von Person, die vom Person-Objekt peter genutzt werden kann.
			
		Mit new erstellen wir eine Instanz von Person und können damit auf die Felder und Methoden davon zugreifen. Wir können Objekte innerhalb von Methoden (zum Beispiel der Main Methode) verwenden um damit zu arbeiten. Hierfür reicht es aus den Bezeichner innerhalb der Methode zu nutzen. Wir können mit dem Punktoperator Felder oder Methoden aufrufen um diese zu nutzen. Wollen wir mehrere Person-Objekte erstelle müssen wir für jedes eine eigene Instanz erstellen. So können wir zum Beispiel den folgenden Beiden Person-Objekten ein unterschiedliches Alter zuweisen:
		
		
			static void Main(string[] args) {
				Person peter = new Person();
				Person britta = new Person();
				
				peter.Alter = 32
				britta.Alter = 21
			
			}
			
		Nicht jede Eigenschaft einer Klasse muss innerhalb eines Objektes einen Wert erhalten, nur die, die wir im Code nutzen. Damit haben wir die Möglichkeit eine Klasse zu schreiben die sehr viele Eigenschaften und Methoden enthällt aus der dann verschiedene Objekte erzeugt werden, die unterschiedliche Dinge tun können.
		
	3.2 Die Klassendefinition
		3.2.3 Deklaration von Objektvariablen
			
			Jedes Objekt benötigt einen Bezeichner. Dieser wird Objektvariable genannt. Die Deklaration einer Objektvariablen ist der einer normalen sehr ähnlich. Erst folgt der Datentyp der Variablen. Da ein Objekt immer bestimmte Eigenschaften und Methoden einer Klasse repräsentiert funktioniert hier die Klasse (wie bereits erwähnt) als Datentyp. Eine Objektvariable ist eine Referenz auf den Speicherplatz in dem sich die Eigenschaften eines Objektes befinden. Deshalb spricht man bei der Objektvariablen davon, dass sie ein Objekt referenziert. Es bildet also eine Instanz aus der Klasse aus der es entsteht. Mit der Deklaration der Objektvariablen wird der Speicherplatz reserviert, das Objekt selbst existiert jedoch noch nicht, da dieses noch nicht initialisiert wurde. Bei der Initialisierung der Objektvariablen verfahren wir wie beim Initialisieren jeder anderen Variablen. Wir haben also folgende beiden Initialisierungsmöglichkeiten:
				
				Circle kreis;
				kreis = new Circle();
				
			und
				
				Circle kreis = new Circle();
				
			Wie wir sehen können nutzen wir bein Initialisieren eines Objektes den Operator new. Erst mit diesem Operator existiert das Objekt. Außerdem ruft new eine ganz bestimmte Methode innerhalb der Klasse die als Konstruktor bezeichnet wird. Dazu später mehr.
			
			Bei der Deklaration sowie der Initialisierung eines Objekts gelten ähnliche Regeln wie bei normalen Variablen. Dies bedeutet, dass wir auch mehrere Objekte aus einer Klasse kommagetrennt in einer Zeile Deklarieren und gegebenenfalls auch schon dort initialisieren können. Hierzu folgendes Beispiel:
			
				Circle kreis1, kreis2 = new Circle(), kreis3;
				
			Hierbei ist zu beachten, dass nur kreis2 schon während der Deklaration initialisiert wurde. Kreis1 und kreis2 müssen trotzdem noch initialisiert werden, wenn sie genutzt werden sollen.
			
		3.2.4 Zugriffsmodifizierer einer Klasse
		
			Beim Entwerfen einer Klasse muss man sich vorher überlegen, diese nur innerhalb der Anwendung zur Verfügung stehen soll in der sie geschrieben wurde oder ob auch anderen Anwendungen darauf zugreifen können sollen. Hierzu gibt es zwei Zugriffmodifizierer. Diese heißen public und internal.
			
			Klasse die den Status public haben können auch von anderen Anwenundungen genutzt werden. Faktisch bedeutet das, dass jeder beliebigen Anwendung die Möglichkeit gegeben wird ein Objekt aus dieser Klasse zu instanziieren um mit diesen dann zu arbeiten.
			
			Bei Klassen mit dem Status internal steht nur der Anwendung in der sich die Klasse befindet die Möglichkeit offen ein Objekt daraus zu instanziieren und zu nutzen.
			
			Man bezeichnet dies auch als Sichbarkeit einer Klasse.
			
		3.2.5 Splitten einer Klassendefinition mit »partial«
		
			Es ist Möglich die Defintion einer Klasse auf mehrere Datein aufzuteilen. Hierfür wird der Modifizierer partial genutzt. Die Aufteilung in Segmente gibt Entwicklern die Möglichkeit gleichzeitig an ein und der selben Klasse zu arbeiten. Zur Nutzung von partial folgendes Beispiel:
			
				//Definition der Klasse Circle in der Quellcodedatei Circle1.cs
				
				partial class Circle [
					[...]
				}
				
				//Definition der Klasse Circle in der Quellcodedatei Circle2.cs
				
				partial Class Circle [
					[...]
				}
			
			Zu beachen ist, dass es vom Code her keinerlei unterschied geben darf, sodass die einzelnen teile einer Klasse problemlos zusammengesetzt werden können. Weiterhin ist zu beachten, dass eine Aufteilung mit partial zwar auf verschiedene Datein geschehen kann, sich aber trotzdem in der gleichen Anwendung befinden muss um zu funktionieren.
			
		3.2.6 Arbeiten mit Objektreferenzen
		
			Prüfen auf Initialisierung
				
				Eine Objektvariable gilt genau dann al initialisiert, sobald sie ein Objekt referenziert oder den Wert null beschreibt. Es ist also neben der oben beschriebenen Initialisierung auch möglich 
				
					Circle kreis = null
					
				zu verwenden um das Objekt kreis mit dem Wert null vor zu initialisieren.
				
				Mit dem Statment
				
					if (kreis == null) {
						Console.WriteLine("Das Objekt existiert nicht");
					}
					else{
						Console.WriteLine("Das Objekt existiert");
					}
					
				lässt sich überprüfen ob ein Objekt bereits initialisiert wurde oder nicht. Zu beachten ist hierbei, dass Eigenschaften und Methoden eines Objektes jedoch nur genutzt werden können, sofern wirklich ein Objekt referenziert wurde und nicht mit null vorinitialisiert wurde.
				
				Freigabe eines Objekts
				
					Objekte belegen Speicher. Sollte es also dazu kommen, dass ein Objekt nicht mehr benötigt wird, sollte der Objektvariablen der Wert null zugewiesen werden. Hiermit wird das Objekt nicht gelöscht, jedoch wird die Referenz auf dieses Objekt entfernt, was dazu führt, dass keinerlei Zugriff darauf mehr Möglich ist. Später wird der Garbage Collector jedoch den Speicher auf auf nicht mehr referenzierte Objekte überprüfen und löschen.
					
				Mehrere Referenzen auf ein Objekt
				
					Mit der Zuweisung
					
						Circle kreis1 = new Circle();
						Circle kreis2 = kreis1;
						
					wird mit kreis1 ein Objekt aus der Klasse Circle Instanziiert und erst der Objektvariablen keis1 zugewiesen. Danach wird mit der zu erkennenden Zuweiseung der Objektvariablen kreis2 eine Referenz auf kreis1 zugewiesen. Es wurde also nur ein Objekt erzeugt auf das von zwei verschiedenen Objektvariablen zugegriffen werden kann. Beide Referenzen haben den gleichen Status, das heißt es ist von beiden aus möglich das Objekt zu manipulieren, Werte ausgeben zu lassen oder sontige Operationen durchführen zu lassen.
					
					Beim Freigeben eines Objektes mit mehreren Referenzen ist zu beachten, dass es erst dann wirklich freigegeben ist, wenn jede einzenere Objektvariable den Wert null erhällt.
					
		3.3 Referenz- und Wertetypen
			3.3.1 Werte- und Referenztypen nutzen
				Der Unterschied zwischen Werte- und Referenztypen liegt in der Bereitstellung von Speicher (Allokierung). Variablen die einen Wertetyp repräsentieren allokieren auf dem sogenannten Stack Speicherplatz für die Daten. Der Stack befindet sich im RAM und wird vom direkt vom Prozessor mit einem sogenannten Stackpointer unterstützt. Dieser ist in der Lage Speicher zu reservieren und freizugeben. Dadurch kann der Stack sehr schnell und effizient arbeiten. Referenztypen werden auf dem sogenannten Heap. Als Heap wird der Speicher im RAM bezeichnet der allgemeinen Zwecken zur Verfügung steht.
				
				Wird zum Beispiel die Variable
				
					int value = 100;
					
				deklariert und intialisiert wird auf dem Stack der benötigte Speicher reserviert, da int als Struktur definiert ist. Hierbei ist zu beachten, dass der Operator new nicht gesetzt werden muss. Bei einem Referenztyp ist dies unverzichtbar da erst mit
				
					Circle kreis = new Circle();
					
				Speicher auf den Heap reserviert wird auf den die Referenz kreis zeigt.
				
				Daraus folgt, dass eine Referenz nie den Wert null haben kann.
				
		3.4 Eigenschaften eines Objekts
			3.4.1 Öffentliche Felder
			
				Ein Objekt unterscheidet sich von einem Typgleichen Objekt durch dessen charakteristischen Eigenschaften. Ein spezifisches Objekt kann mehr/weniger und vollkommen andere Eigenschaften haben als ein typgleiches anderes Objekt. Dies liegt immer daran, welche Vorraussetzungen an das Objekt gestellt werden. Da jedes Objekt bekanntermaßen eine Instanz einer Klasse dastellt müssen alle Eigenschaften die an die einzelnen Objekte gestellt werden innerhalb der Klasse aus der instanziiert wird berücksichtigt werden/vorhanden sein. Hierzu werden die Werte in Variablen gespeichert die vorher in der Klasse definiert wurden. Welche Eigenschaften einer Klasse jedes einzelne Objekt nutzt liegt wie bereit erwähnt in der Vorraussetzung, die an das Objekt gestellt wird.
				
				Eigenschaften/Felder sind nichts anderes als Variablen die innerhalb einer Klasse definiert wurden. Der Unterschied zu einer Variablen innerhalb einer Methode ist dessen Sichtbarkeit. Definieren wir zum Beispiel ein Feld Radius wie folgt
				
					public int Radius;
					
				ist diese durch den Zugriffsmodifizierer public, so steht dieses Feld überall zur Verfügung und kann auch von anderen Klassen und/oder Objekten etc. genutzt bzw. manipuliert werden. Es ist zu beachten, dass ein Feld, sofern es nicht mit einer Zahl initialisiert wurde immer mit einem Standartwert vorinitialisiert. In diesem Beispiel ist
				
					public int Radius;
				
				also das gleiche wie
				
					public int Radius = 0;
					
				Um auf eine Eigenschaft zugreifen zu können müssen wir nur den Objektnamen einen Punkt (.) und danach den Eigenschaftsbezeichner angeben. Wir instanziieren also als erstes ein Objekt 
				
					Circle kreis = new Circle();
					
				und weisen dann dem Radius mit
				
					kreis.Radius = 10;
					
				den Wert 10 zu.
				
			3.4.2 Datenkapselung mit Eigenschaftsmethoden sicherstellen
			
				In unserem gewählten beispiel haben wir nciht berücksichtigt, dass auch ein negativer Wert in die Eigenschaft Radius geschrieben werden könnte was keinen Sinn macht. Um eine Prüfung durchzuführen bieten sich sogenannte Eigenschaftsmethoden an. Diese Eigenschaftsmethoden haben jeweils zwei seperate Subroutinen die je nach Bedarf ausgeführt werden. Diese heißen set und get. Soll einem Feld ein Wert zugewiesen werden, so nutzen wir die set Operation, soll hingegen der Wert ausgewertet werden, so wird die get Operation ausgeführt.
				
				Es ist zu beachten, dass wir der Eigenschaftsmethode den Namen des eigentlichen Feldes geben und dem Feld selbst mit einem Unterstrich vor dem Bezeichner umbenennen um einem Bezeichnerkonflikt aus dem Weg zu gehen. Des Weiteren ist es ratsam das Feld mit dem Zugriffsmodifizierer private insofern einzuschrenken, dass es nurnoch innerhalb der Klasse sichtbar ist in der es definiert wurde und auch nur von dort manipuliert werden kann, da wir der Eigenschaftsmethode den Zugriffsmodifizierer public geben. Die Implementierung eines solchen Prüfmechanismus könnte wie folgt aussehen:
				
					public class Circle {
						private int _Radius
						
						public int Radius {
							set {
								if (value <= 0) {
									_Radius = value;
								}
								else{
									Console.WriteLine("Der Radius muss einen positiven Wert haben");
								}
							}
							get{
								return _Radius;
							}
						}
					}
				
				Dieses Prinzip wird ganz allgemein als Datenkapselung bezeichnet. Es ist zu beachten, dass wir innerhalb der set Operation einen Parameter namens value nutzen. Dieser muss auch immer value lauten und nimmt automatisch den richtigen Datentyp an. In unserem Beispiel ist value also vom Typ int.
				
			3.4.4 Lese- und schreibgeschützte Eigenschaften
			
				Eigenschaften können schreib- bzw. lesegeschützt sein in dem man entweder die set oder die get Operation nicht angiebt. Die fehlende Operation kann zum Beispiel von einer anderen Methode durchgeführt werden. Auf diese weise ist es möglich zu verhindern, dass aus einer bestimmten Methode heraus ein Wert zum Beispiel manipuliert wird.
				
			3.4.5 Sichtbarkeit der Accessoren get und set
			
				Standartmäßig haben die Accessoren get und set die gleiche Sichbarkeit wie die Eigenschaftsmethode in der sie stehen. Es ist jedoch möglich eine abweichende Sichtbarkeit anzugeben. Hierbei ist zu beachten, dass nur einer der Accessoren einen abweichenden Zugriffsmodifizierer haben darf. Des Weiteren müssen beide Accessoren angegeben sein, wenn einer davon eine abweichende Sichtbarkeit aufweisen soll. Letztlich muss der Zugriffsmodifizierer der Accessoren einschränkender sein als der der Eigenschaftsmethode.
				
		3.5 Methoden eines Objekts
			3.5.1 Methoden mit Rückgabewert
			
				Die allgemeine Syntax einer Methode mit Rückgabewert sieht wie folgt aus:
				
					[Modifizierer] Typ Bezeichner ([Parameterliste]) {
						[...]
						return Wert;					
					}
				
				Der Modifizierer kann entweder ein Zugriffsmodifizierer sein oder die Methoder weiterführend beeinflussen, zum Beispiel für die Vererbung. Der Modifizierer einer Methode ist jedoch optional. Folgende Zugriffsmodifizierer stehen zur Verfügung:
				
					public					Die Methode kann von überall aus aufgerufen werden
					private					Die Methode kann nur innerhalb der Klasse in der Sie erstellt wurde genutzt werden
					protected				Die Methode steht nur innnerhalb dieser und für abgeleitete Klassen zur Verfügung
					internal				Die Methode steht nur Programmcode innerhalb der Anwendung zur Verfügung in der sie definiert ist
					protected internal		Stellt eine Kombination der Beiden Modifizierer protected und internal dar.
					
				Zu beachten ist, dass eine Methode bei der auf einen Zugriffsmodifizierer verzichtet wird automatisch als private definiert wird.
				
				Methoden können als Folge eines Aufrufs ein Ergebnis an den Aufrufer zurückliefern. Hierzu wird der Operator return genutzt. Kommt es zur Ausführung der Programmzeile die den return Operator beinhaltet wird der Wert zurückgegeben und an die aufrufende Stelle zurückgegeben. Das führt dazu, dass Programmcode innerhalb einer Methode der nach dem return Operator steht nicht mehr ausgeführt wird. Gegeben sei folgende Methode die innerhalb der Klasse Circle die Grundfläche berechnet:
				
					public class Circle {
						[...]
						int Radius = 12;
						
						public double GetArea() {
							double area = Math.Pow(Radius, 2) * Math.PI;
							return area;
						}
					}
				
				Wie Zu sehen ist, wird eine public Methode mit einem Großbuchstaben benannt und besteht weiterhin aus einer aussagekräftigen Kurzbeschreibung Ihrer Funktion. Dabei ist zu beachten, dass aus Gründen der besseren Lesbarkeit für jedes Wort das genutzt wird jedes Wort mit einem Großbuchstaben beginnt.
				Um den Code kürzer zu halten ist es außerdem möglich eine Operation innerhalb der Zeile zu vollziehen inder der return Operator gesetzt ist. Hierbei ist wichtig, dass der Wert der Operation den gleichen Datentypen zum Ergebnis hat, der beim Methodenaufruf verlangt wird oder alternativ in diesen impliziert konvertiert werden kann. Ist dies nicht gegeben muss eine expliziete Konvertireung vorgenommen werden!
				Der folgende Code führt also zum gleichen Ergebnis wie der oben angegebene:
				
					publich class Circle {
						[...]
						int Radius = 12;
						
						public double GetArea() {
							return Math.Pow(Radius, 2) * Math.PI;
						}
					}
				
				Somit ist es möglich eine Methode wie eine Variable zu behandeln, da diese einen Konkreten Wert zurückgibt. Uns ist damit die Möglichkeit gegeben, mit dem Aufruf einer Methode weiterzurechnen. Hierzu folgendes Beispiel:
				
					Circle kreis = new Circle();
					kreis.Radius = 10;
					int height = 30;
					double volume = kreis.GetArea() * height;
				
				Es ist nicht zwingend erforderlich den Rückgabewert einer Methode in einer Variablen zu speichern. So kann zum Beispiel in einer Konsolenanwendung durch den Console.WriteLine Befehl direkt eine Methode mit Rückgabewert angegeben werden, die dann wie eine Variable das Ergebnis an die Konsole weitergibt. Der Rückgabewert einer Methode muss nicht zwangsläufig entgegengenommen werden, sondern kann auch einfach ignoriert werden.
				
			3.5.2 Methoden ohne Rückgabewert
			
				Allgemeine Syntax einer Methode ohne Rückgabewert:
				
					[Modifizierer] void Bezeichner ([Parameterliste]) {
						[...]
					}
				
				Hierbei ist zu beachten, dass an Stelle des Datentyps einer Methode das Schlüsselwort void steht. Der return Operator kann jedoch auch in Methoden ohne Rückgabewert genutzt werden um diese zu terminieren.
			
			3.5.3 Methoden mit Parameterliste
			
				Für manche Methoden ist es notwendig, dass sie für den Durchlauf dateninformationen benötigen. Hierzu dient die Parameterliste die bei der Definition der Methode angegeben wird. Parameter werden wie Variablen definiert. Folgend ein Beispiel für eine Methode mit Parametern:
				
					public void Move(double dx, double dy) {
						XCoordinate += dx;
						YCoordinate += dy;
					}
					
				In dieser Methode namens Move werden die X bzw. Y Koordinaten verändert. Um die neuen Koordinaten berechnen zu können müssen vorher die alten angegeben werden.
				
			3.5.4 Methodenüberladung
			
				Eine Methode kann mehr als einmal unter dem gleichen Bezeichner geführt werden. Die Methode wird dann als überladen bezeichnet. Bei der Überladung von Methoden ist zu beachten, dass diese als überladen gilt wenn 
				
					sich gleichnamige Methoden in der Anzahl der Parameter unterscheiden oder
					
					bei gleicher Parameteranzahl mindestens einer der Parameter einen anderen Datentyp aufweist.
					
				Gibt eine Methode ein Ergebnis zurück, dass einen anderen Datentyp besitzt als die andere Methode gilt diese nicht als überladen. Außerdem gilt eine Methode nicht als überladen, wenn sich die Parameter nur im Bezeichner unterscheiden.
				
				Kommt es dazu, dass der Compiler die entscheidung fällen muss, welche Methode genutzt werden muss kann es bei numerischen Methoden durchaus zu Verwirrung kommen. Gehen wir davon aus, dass wir eine Methode überladen in dem wir dem Parameter einmal den Datentyp int und einmal den Datentyp long definieren. Beim Aufruf der gleichnamigen Methode wird es immer dazu kommen, dass die int Methode aufgerufen wird (es sei denn es wird voher explizit in den Typ long konvertiert), da ein ganzzahliger Wert standartmäßig als int interprätiert wird.
				
				Überladene Methoden werden dann genutzt wenn es nötig ist eine Basisfunktionalität unter angabe unterschiedlicher Parameter durchzuführen. Erweitert eine Methode eine andere (besitzt diese zu den in der ersten entahlatenen Parameter noch weitere) so kann man die erste Funktion dazu nutzen, die übergebenen Parameter die diese akzeptiert zu verarbeiten und die zweite Methode nur die erweiterte Funktion selbst verarbeiten lassen. Dies spart Codezeilen und doppelten Code.
				
				
			3.5.5 Variablenö innerhalb einer Methode (lokale Variablen)
			
				Variablen die innerhalb einer Methode definiert sind bezeichnet man als lokale Variablen. Diese sind nur innerhalb der geschweiften Klammern der Methode sichtbar. Außerhalb davon sind sie weder bekannt, sichtbar noch können sie manipuliert oder ausgewertet werden. Lokale Variablen sind auch in Schleifen oder anderen Anweisungen wie z.B. dem if Statement zu finden. Auch hier existiert die lokale Variable nur innerhalb der geschweiften Klammern. Werden Statement inerinander geschachtelt (zum Beispiel eine Schleife in einem If) und eine lokale Variable im äußeren KLammernpaar definiert (also im If), steht diese variable auch im untergeordneten Statement (der Schleife) zur Verfügung aber nciht umgekehrt. Die Lebenszeit einer Lokalen Variablen beschränkt sich auf die Dauer der Methodenausführung. Ist die Methode zuende wird die Variable samt ihrem Wert gelöscht. Bei einem neuen Aufruf der Methode wird eine neue lokale Variable erstellt. Es ist zu beachten, dass eine lokale Variable immer initialisiert werden sollte, da die Nutzung einer nicht initialisierten lokalen Variable zu einem Kompilierfehler führt.
				
			3.5.6 Referenz- und Werteparameter
			
				Parameter ohne zusätzliche Modifizierer
					
					Gegeben sei folgendes Teilprogramm:
					
						class Program {
							
							Static void Main(string[] args) {
								int value = 3;
								DoSomething(value);
								Console.WriteLine("value = " + value);
								Console.ReadLine();
							}
							
							static void Dosomething(int param) {
								param = 550;
							}
						}
						
					Wenn wir und dieses Listing ansehen könnte man denken, dass in der Konsole 550 ausgegeben wird. tatsächlich wird aber 3 ausgegeben. Um zu verstehen warum dies der Fall ist folgende Erklärung.
					
					Beim speichern der lokalen Variablen value wird im Speicher auf einer bestimmten Adresse (wir gehen von der Adresse 1000 aus) der benötigte Speicher für ein int allokiert. Dort wird die Zahl 3 hereingeschrieben. Danach wird die Methode DoSomething aufgerufen der als parameter der Wert von Value übergeben wird. Diesem Parameter soll nun der Wert 550 zugewiesen werden. Hierfür wird nochmals Speicher allokiert und zwar auf einer anderen Adresse für die Variable param (wir gehen hier von der Adresse 2000 aus). Es wird also Faktisch der Wert von Adresse 1000 an Adresse 2000 übergeben und dort mit dem wert 550 überschrieben. Nachdem dies geschehen ist wird wie zu sehen ist value ausgegeben. Hierbei ist zu beachten, dass value immernoch in der Adresse 1000 ist und dort den Wert 3 hat, Weshalb in der Konsole auch dieser Wert ausgegeben wird.
					
					Dies wird Werteübergabe (engl. Call by value) genannt.
					
				Parameter mit dem Modifizierer ref
				
					Folgende Modifizierung des gegebenen Teilprogramms sei nun gegeben:
					
						DoSomething(ref value);
						
						public void DoSomething(ref int param){
							[...]
						}
						
					Hiermit geben wir an, dass beim Aufruf der Methode DoSomething nicht der Wert an sich, sondern die Speicheradresse übergeben wird. Damit der Parameter der Methode weiß, was er übergeben bekommt muss dieser auch den Modifizierer ref erhalten. Obwohl auch für den Parameter param Speicherplatz allokiert wird (wir gehen wieder von den gleichen Adressen aus) wird jeder Aufruf an die Adresse 2000 and die adresse 1000 weitergeleitet. Value erhält faktisch also den Wert 550 der auch in der Konsole ausgegeben wird.
					
					Dies wird als Referenzübergabe (engl. Call by reference) bezeichnet.
					
					Wird call by reference genutzt sind folgende Regeln zu bachten:
					
						-In der Parameterliste der Methode muss der Modifizierer ref angegeben werden
						-Im Methodenaufruf muss dem übergebenen Argument der Modifizierer ref vorangstellt werden
						-Das zu übergebende Argument muss initialisiert sein
						-Das Übergabeargument darf keine Konstante sein
						-Das Übergabeargument darf nicht aus einem berechneten Ausdruck in Form eines Methodenaufrufs bezogen werden
						
					Das bedeutet im letzten Fall dass
					
						@object.DoSomething(ref a, ref obj.ProcB());
						
					nicht zulässig ist, da erst mit Aufruf der Methode ein wert berechnet wird der übergeben werden soll.
					
				Parameter mit dem Modifizierer out
				
					Der Modifizierer out ähnelt dem Modifizierer ref. Er wird genauso angegeben (bei der Übergabe und in der Parameterliste der Methode) hat aber die Unterschiede, dass bei der Übergabe der Referenz nicht zwingend eine initialisierte Variable dahinterstehen muss. Dementsprechen muss innerhalb einer Methode deren Argumente mit out übergeben werden jedoch eine Wertzuweisung stattfinden.
					
					Allgemein ist bei der Nutzung von ref bzw. out zu beachten, dass wir hierbei mit den Orginalwerten arbeiten und diese manipulieren. Dies kann dazu führen, dass im weiteren Programmverlauf Änderungen vorgenommen werden, die so nicht vorgesehen waren, wenn man ref und out unbedacht einsetzt.
					
				Übergabe von Objekten
				
					Ein Objekt wird prinzipiell als Referenz übergeben. Dies führt dazu, dass bestimmte Werte innerhalb des Orginalobjekts geändert werden. um dies zu verhindern muss erst eine Kopie des Objekts erstellt werden bevor man Werte darin ändert.
					
				Methodenüberladung und Parametermodifizierer
				
					Ergänzent zum Teilkapitel über die Überladung von Methoden ist zu erwähnen, dass eine Methode auch als überladen gilt, wenn sie einmal durch call by value und einmal durch call by reference angegeben ist. Als nicht überladen gelten hingegen Methoden von der eine Argumente via ref und die andere via out zugewiesen bekommt, da beides Referenztypen sind.
					
			3.5.7 Besondere Aspekte einer Parameterliste
			
				Übergabe eines Arrays an die Parameterliste
				
					Es ist auch möglich ein Array als Argument an eine Parameterliste einer Methode zu übergeben. dafür wird folgende allgemeine Syntax verwendet:
					
						[Zugriffsmodifizierer] [Datentyp] [Methodenbezeichner] ([Datentyp][] [Arraybezeichner]) {
							[...]
						}
						
				Der Modfizierer params
				
					Es kannd durchaus vorkommen, dass noch nicht bekannt ist, wieviele Argumente an die Methode übergeben werden sollen. Oder es soll möglich sein rein theoretisch unendlich viele Argumente als Parameter zu übergeben. Hierfür gibt es den Parameter params. Wird an einen params-Parameter mehr als ein Wert übergeben, so werden diese innerhalb eines Arrays (mit dem bezeichner params) übergeben. Will man zum Beispiel eine Methode schreiben die beliebig viele Zazhlen miteinander addieren kann, so macht es sinn, params zu nutzen um sicherzustellen, dass beliebig viele Argumente übergeben werden können. Es können trotzdem weitere feste "Einzelparameter" angegeben werden. dies würde für unsere Beispielmethode auch Sinn machen, da man eine Addition traditionell mit mindestens zwei Zahlen durchführt.
					
				Mit dem params-Parameter gehen folgende Regeln einher:
				
					-in der Parameterliste darf nur ein Parameter mit params festgelegt werden
					-ein Params-Parameter steht immer an letzter Stelle in einer Parameterliste
					-eine Kombination mit den Modifikatoren ref und out is unzulässig
					-ein params parameter ist grundsätzlich eindimensional
					
				Zum letzten Punkt ist zu sagen, dass das params Array anhand der übergebenen Werte automatisch dimensioniert wird.
				
				Um dem params Parameter Werte zuzuweisen gibt es zwei Möglichkeiten. Entweder übergibt man die Referenz auf einen Wert oder man übergibt einfach mehrere Werte.
				
			Optionale Parameter
			
				Bei optionalen Parametern handelt es sich um Parameter denen schon in der Parameterliste ein Standartwert zugewiesen wurde. Damit bleibt dieser Parameter solange auf diesem Wert bis ihm bei einem Methodenaufruf explizit ein Wert zugewiesen wird. Damit ist die Angabe eines Wertes für diesen Parameter nicht zwingend erforderlich. Hierbei ist zu beachten, dass wenn eien Methode sowohl feste als auch optionale Parameter besitzt, dass erst die festen, dann die optionalen angegeben werden müssen. Um zu überprüfen ob einem optionalen Parameter ein Wert übergeben wurde reicht es damit aus zu überprüfen, ob der Wert des Parameters vom Standartwert abweicht.
			
			Methodenaufruf mittels benannter Argumente
			
				Es ist weiterhin möglich feste Werte an einen Parameter weiter zu geben. Hierzu wird beim Methodenaufruf der Parameterbezeichner dann einem Doppelpunkt und dann dem Wert der Übergeben werden soll angegeben. Es können sowohl benannte als auch unbenannte Parameter an eine Methode übergeben werden hierbei ist jedoch zu beachten, dass erst die unbenannten und dann die benannten Parameter angegeben werden.
				
		3.5.9 Die Trennung von Daten und Code
		
			Objekte bestehen allgemein aus Eigenschaften (Daten) und Methoden (Code). Hierbei ist zu beachten, dass ein Objekt als Instanz einer Klasse immer einen Festen Speicherblock im Speicher reserviert der die Größe aller Eigenschaften umfasst. Dieser ist für jedes Objekt desselben Typs gleich groß. Methoden hingegen werden nur einmal im Speicher festgelegt und können von dort aus abgerufen werden. Bei diesem Prinzip spricht man von der Trennung von Daten und Code.
			
		3.5.10 Namenskonflikte mit this lösen
		
			Da lokale Variablen nur innerhalb eines Methodenblocks gültig sind dürfen die Bezeichner durchaus gleich sein wie die eines Feldes. Dies kann natürlich dazu führen, dass bei einer Wertzuweisung dieses Bezeichners das Problem auftritt, dass evtl. der falsche Bezeichner den Wert erhält. Wird innerhalb einer Methode dem gleichnamigen bezeichner ein Wert zugewiesen, so wird die lokale Variable diesen Wert erhalten, die diese stärker bindet als das Feld gleichen namens. Möchte man jedoch auf das Feld zugreifen so muss dem Bezeichner das Schlüsselwort this vorangestellt werden.
			
		3.6 Konstruktoren
		
				Konstruktoren sind spezielle Methoden einer Klasse die aufgerufen werden, sobald ein Objekt daraus instanziiert wird. Dieses wird zum Beispiel genutzt um einem Objekten sofort Werte zu übergeben die für den weiteren Verlauf nötig sind, eine Datenbankverbinduntg aufzubauen oder eine Datei zu öffnen. Sie dienen also zum kontrollierten Initialisieren eines Objekts. Konstruktoren werden aufgerufen sobald ein Objekt mit dem new Operator instanziiert wird.
				
				Genau wie Methoden, lassen sich auch Konstruktoren überladen. Allerding haben Konstruktoren niemals einen Rückgabewert nichtmal void. 
				
				Die allgemeine Syntax einer Konstruktors sieht wie folgt aus:
				
					[Zugriffsmodifizierer] [Klassenbezeichner]() {
						[...]
					}
					
				Wird ein Objekt erstellt wird im ersten Schritt der benötigte Speicherplatz allokiert und im zweiten Schritt der Konstruktor aufgerufen, der das Objekt initialisiert.
			
			3.6.1 Konstruktoren bereitstellen
			
				Mit parametrisierten Konstruktoren ist es möglich Werte schon während der Erstellung eines Objekts zuzuweisen. Hierzu folgende 3 Besipiele die zeigen, wie man Überladung von Konstruktoren nutzen kann um einem Objekt zum Zeitpunkt der Erstellung Werte zu übergeben.
				
					public Circle() {}
					
					public Circle(int radius) {
						Radius = radius;
					}
					
					public Circle(int Radius, double x, double y) {
						XCoordinate = x;
						YCoordinate = y;
						Radius = radius;
					}
					
			3.6.2 Die Konstruktoraufrufe
			
				Im oben angegebenen Fall ist zu sehen, dass es nun möglich ist ein Objekt aus der Klasse Circle auf 3 verschiedene Arten zu initialisieren. Hierbei wird der Compiler den richtigen Konstruktor automatisch aussuchen. Sollte es hierbei zu Doppeldeutigkeiten kommen wird der Compiler einen Fehler ausgeben.
				
			3.6.3 Definition von Konstruktoren
			
				Es ist zu beachten, dass neben den bereits erwähnten Regeln noch dazu kommt, dass ein konstruktor nur beim Erzeugen eines Objekts aufgerufen wird, nicht aber auf ein bestehendes Objekt angewandt werden kann um zum Beispiel Werte zu ändern, die man während der Initialisierung hätte setzen können bzw. gesetzt hat.
				Außerdem ist zu beachten, dass es einen impliziten Standartkonstruktor gibt, der parameterlos ist. Bestimmt man jedoch explizit einen Konstruktor kann dieser "unsichtbare" Standartkonstruktor nicht mehr aufgerufen werden. Möchte man jedoch immernoch ein Objekt initialisieren können ohne einen Parameter zu übergeben ist es notwendig einen parameterlosen Konstruktor explizit zu erstellen.
				
			3.6.4 public und internal Konstruktoren
			
				Während der implizierte Standartkonstruktor immer public ist, kann man durchaus auch einen internal Konstruktor erstellen der nur innerhalb der Anwendung genutzt werden kann in der die Klasse erstellt wurde.
				
			3.6.6 Konstruktoraufrufe umleiten
			
				Es ist möglich einen Konstruktor implizit durch einen anderen aufzurufen. Hierzu wird ebenfalls das Schlüsselwort this verwendet. Der this Operator wird, getrennt von einem Doppelpunkt nach der Prameterliste geschrieben. Hiermit wird sichergestellt das der angegebene Parameter weiteren Konstruktoren zur Verfügung gestellt wird. Die folgende Syntax beschreibt diese Vorgehensweise beispielhaft:
				
					public Circle (int radius) {
						Radius = radius;
					}
					
					public Circle (int radius, double x, double y) : this(radius) {
						XCoordinate = x;
						YCoordinate = y;
					}
					
				Wird ein Parameter an einen anderen Konstruktor weitergeleitet wird dieser komplett ausgeführt und gibt die Kontrolle dann an den aufrufenden Konstruktor zurück.
				
				Konstruktorverkettung - die bessere Lösung
				
					Gehen wir einmal davon aus, dass wir eine komplexe Struktur von Konstruktoren haben, die jeweils andere aufrufen um Parameter weiterzuleiten. In diesem Fall haben wir neben einem Leistungsabfall des Programms (da jeder einzelne Konstruktor ausggeführt wird) auch das Problem, dass die Programmlogik unübersichtlich wird, da wir diese an viele verschiedene Stellen des Codes verteilen. Aus diesem Grund sollte man bei Verkettungen von Konstruktoren darauf achten die gesamnte initialisierungslogik in den Konstruktor zu coden, der die meisten Parameter erwartet. Wird ein anderer Konstruktor aufgerufen der über weniger Parameter verfügt sollte man die angegebenen weiterleiten und für die nicht vorhandenen einen Standartwert weiterleiten. Auf diese Weise bleibt der Code übersichtlich und efizient.
					
			3.6.7 Verweinfachte Objektinitialisierung
			
				Es ist möglich ein Objekt zu initialisieren und dabei neben der Standartschreibweise
				
					Circle kreis = new Circle (12, -100, 250)
					
				auch die Schreibweise innerhalb der geschweiften Klammern zu nutzen:
				
					Circle kreis = new Circle() { XCoordinate = -100, Radius = 12, YCoordinate = 250 }
					
				Wie zu sehen ist spielt es in dieser Schreibweise keine Rolle in welcher Reihenfolge die Werte angegeben werden. Zu beachten ist hier, dass ein Wert der auf diese weise angegeben wird die Zuweisung eines evtl. vorhandenen Konstruktors der der gleichen Variable einen Wert zuweist überschreibt bzw. wird die Zuweisung des Konstruktor ignoriert. Dass bedeutetet, dass
				
					Circle kreis = new Circle(30) {Radius = 550}
					
				Dem Objekt kreis einen Radius von 550 zuweist und NICHT von 30.
			
		3.7 Der Destruktor
		
			Das Gegenstück zum Konstruktor ist der Destruktor. Wenn entweder die Objektvariable Ihren Gültigkeitsbereich verlässt oder der Referenz auf ein Objekt der Wert null zugewiesen wird, steht es, wie bereits erwähnt nicht mehr zu Verfügung. Dies bedeutet im allgemeinen jedoch nicht, dass der Destruktor aufgerufen wird. Dies geschiet durch den Garbage Collector, der normalerweise durch die Laufzeitumgebung selbst angestoßen wird. Die Syntax des Destruktors sieht wie folgt aus:
			
				~Circle()
				{
					[...]
				}
				
			Es ist zu beachten, dass ein Destruktor weder einen Zugriffsmodifizierer noch die angabe eines Rückgabewertes besitzt.
			
		3.8 Konstanten in einer Klasse
			3.8.1 Konstanten mit dem Schlüsselwort const
			
				Will man einen Wert angeben der innerhalb des Programms nicht geändert werden darf so nutzt man das Schlüsselwort const zwischen Zugriffsmodifizierer und Datentyp:
				
					public class Mathematics {
						public const double PI = 3.14;
						[...]
					}
					
				Einer Konstante kann nur ein Wertetyp zugewiesen werden, also int, long, double etc. . Referenztypen sidn nciht zugelassen. Die einzige Ausnahme bildet hier string.
				
			3.8.2 Schreibgeschützte Felder mit readonly
			
				Neben dem definieren von Konstanten mit const ghibt es außerdem die Möglichkeit Konstanten mit readonly zu definieren. Dies geschieht Syntaktisch genau wie das Defninieren mit const. Der Unterschied ist, dass die Festlegung eines Wertes für readonly Felder sowohl in der Deklaration als auch innerhalb eines Konstruktors erfolgen kann (die Zuweisung innerhalb einer Methode ist jedoch nicht möglich). Es ist bei readonly außerdem möglich Referenztypen zu nutzen. Folgender Code zeigt hierzu ein Beispiel:
				
					class Coordinate{
						public readonly int XCoordinate;
						public readonly int YCoordinate;
						
						public Coordinate(int x, int y) {
							XCoordinate = x;
							YCoordinate = y;
						}
					}
					
		3.9 Statische Klassenkomponenten
			3.9.1 Statische Eigenschaften
		
				Als statische Eigenschaften (auch Klassenvariablen) werden Eigenschaften bezeichnet, die nicht spezifisch für ein spezielles Objekt, sondern für die gesamte Klasse bzw die Klasse selbst notwendig/gültig sind. Dies macht zum Beispiel dann Sinn, wenn wir wissen wollen wieviele Objekte aus einer Klasse instanziiert wurden. Diese Information ist für das Objekt welches initialisiert wird nicht direkt von Belang, für die Klasse jedoch schon. Aus diesem Grund wird eine statische Eigenschaft genutzt, die zu keinem Konkreten Objekt eine beziehung hat aber für alle Objekte der Klasse in der diese Eigenschaft definiert wurde gültig ist.
				
				Um eine statische Eigenschaft zu nutzen schreiben wir das Schlüsselwort static zwischen Modifizierer und Datentyp. Die allgemeine Syntax lautet demnach:
				
					[Modifizierer] static [Datentyp] [Bezeichner];
				
				Da Klassenvariablen unabhänig von jedem konkreten Objekt sind ist es unzulässig sie auf einer Objektreferenz aufzurufen. Stattdessen werden sie aus der Klasse direkt aufgerufen. Will man also die Anzahl der bereits gezählten instanziierten Objekte zählen (natürlich nachdem man eine Methode geschrieben hat die dieses tut) so kann man dies mit
				
					int x = Circle.CountCircles;
					
				tun.
				
				Für statische Felder gelten die gleichen Regeln der Datenkapselung wie für nicht statische Felder (Instanzvariablen). Dies bedeutet, dass wir eine Klassenvariable private deklarieren und mithilfe einer statischen Eigenschaftsmethode den Zugriff darauf regeln müssen. Um zu verhindern, dass die Klassenvariable von außerhalb manipuliert werden kann lassen wir den set Operator innerhalb der statischen Eigenschaftsmethode weg. Um dem Klassenvariablen trotzdem einen Wert zuweisen zu können müssen wir diese mit dem this Schlüsselwort direkt ansprechen.
				
				Wie bereits erwähnt brauchen wir eine Methode die den Counter erhöht sobald ein Objekt initialisiert wird. Dazu macht es sinn den Konstruktor zu nutzen. Hierzu folgendes Beispiel:
				
					// Konstruktoren
					
					public Circle () : this(0, 0, 0) {}
					
					public Circle(int radius) :this(radius, 0, 0) {}
					
					public Circle(int radius, double x, double y) {
						XCoordinate = x;
						YCoordinate = y;
						Radius = radius;
						Circle._CountCircle++;
					}
					
				Hierbei ist zu beachten, dass man einen solchen Counter am Ende der Methode schreiben sollte. Kommt es zum Beispiel zu einem Fehler in den Zeilen davor, was dazu führen kann, dass kein Objekt erstellt wird, so würde der Counter, wenn er an erster Stelle implementiert wäre, einen falschen Wert annehmen.
				
			3.9.2 Statische Methoden
			
				Neben static deklarierten Feldern gibt es auch static deklarierte Methoden. Das Schlüsselwort static wird dabei an der gleichen Stelle geschrieben wie bei Klassenvariablen. Ansonsten bleibt die Syntax der static Methode (Klassenmethode) gleich der einer Methode innerhalb eines Objektes (Instanzmethode). Klassenmethoden sind uns schon häufig während der Programmierung begegnet. Zum Beispiel sind die Methoden WriteLine bzw. ReadLine Statische Methoden der Klasse Console. Eine Weitere Klasse die nicht nur static Methoden nutzt, sondern ausschließlich aus diesen besteht ist die Klasse Math, weshalb wir diese hier nutzen um Beispiele anzubringen.
				
				Sind innerhalb einer Klasse sowohl Klassenmethoden/Klassenvariablen als auch Instanzmethoden/Instanzvariablen vorhanden gelten folgende Zugriffsregeln von einem zum anderen:
				
					-Aus einer Instanzmethode heraus lassen sich Klassenvariablen manipulieren und Klassenmethoden aufrufen
					-Der umgekehrte Weg, nämlich aus einer statischen Methode heraus auf Instanzeigenschaften und Instanzmethoden zuzugreifen, ist nicht möglich. Dies ist logischerweise dem Fakt geschuldet, dass der Zugriff nicht eindeutig ist, da es immer mehrere Objekte des entprechenden Typs geben kann.
					
				Wollen wir zum Beispiel Methoden bereitstellen mit denen wir die Grundfläche bzw. den Umfang eines beliebigen Kreises berechnen wollen ohne dafür ein Objekt erzeugen zu müssen könnten wir folgende beiden static deklarierten Methoden definieren:
				
					public static double GetArea (int radius) {
						return Math.PI * Math.Pow(radius, 2);
					}
					
					public static double GetCircumference(int radius) {
						return 2 * Math.Pi * radius;
					}
					
					Es ist zu beachten, dass eine gültige Überladung stattfinden muss, sofern es Instanzmethoden gibt die ebenfalls den Umfang bzw die Grundfläche berechnen. der modifizierer static reicht nciht aus um eine gültige Überladung zu erzeugen.
					
				3.9.3 Statische Klasseninitialisierer
				
					Es ist möglich eine static deklarierten Konstruktor zu erzeugen. Dieser Konstruktor (auch statischer Konstruktor oder statischer Initialisierer) hat nur auf die als static deklarierten Felder und Methoden Zugriff. Weiterhin wird dieser nur ein einziges mal aufgerufen und zwar direkt bevor ein static Member aufgerufen oder manipuliert wird bzw. wenn eine Instanz der Klasse erzeugt wird.
					
					Die Syntax eines als static deklarierten Konstruktor ist dem eines normalen sehr ähnlich. Ihm wird das Schlüsselwort static vorrangestellt und er besitzt nie einen Zugriffsmodifizierer. Da ein statischer Konstruktor immer automatisch aufgerufen wird und niemals direkt, macht auch eine Parameterliste keinen Sinn, die runden Klammern sind deshalb grundsätzlich leer.
					
					Aufrufreihenfolge der Konstruktoren
					
						Der statische Konstruktor wird prinzipiell als erstes aufgerufen, was es ermöglicht dem nicht statischen Konstruktor Werte zu übergeben die erst durch den statischen Konstruktor erzeugt werden.
						
				3.9.4 Statische Klassen
					
					Es ist möglich eine ganze Klasse als static zu deklarieren. Ein Beispiel für diese Klassen ist die bereits angesprochene Klasse Math. Bei der Erstellung statischer Klassen sind folgende Fakten zu beachten:
					
						-Statische Klassen dürfen nur statische Klassenmidglieder haben. Der Modifizierer static ist auch bei den Membern anzugeben.
						-Statische Klassen enthalten keinen Konstruktor und können deshalb auch nicht instanzziert werden. Der parameterlose Konstruktor ist implizit private.
						
				3.9.5 Statische Klasse oder Singleton-Pattern?
			
					Eine statische Klasse macht genau dann Sinn, wenn wir verhindern wollen, dass ein Objekt aus dieser Klasse erzeugt werden kann. Dasselbe Ziel mit einem etwas anderen Ansatz wird durch ein Design Patter, ein sogenanntes Singleton-Pattern, verfolgt.
					
					Als Design Pattern bezeichnet man allgemeine verwendbare Lösungsansätze für immer wiederkehrende Probleme im Umfeld eines Softwareentwurfs. Design Pattern beschreiben also im weitestgehenden Sinn Schablonen, die in einem bestimmten Kontext einer Software immer wieder verwendet werden können.
					
					Betrachten wir dazu das folgende Singleton-Pattern am konkreten Beispiel der Klasse Demo:
					
						public class Demo {
							private static Demo	_Instance = null;
							public int Value {get; set;}
							
							private Demo() {}
							
							public static Demo Instance {
								get {
									if(_Instance == null) {
										_Instance = new Demo();
									}
									return _Instance
								}
							}
						}
						
					Wie zu sehen ist gibt es ein statisches Feld _Instance und einen Kontruktor, der als private deklariert ist. Damit kann man aus diesem Pattern nur innerhalb desselben ein Objekt erzeugen. Des Weiteren besitzt die Klasse eine statische Methode die als erstes prüft, ob bereits ein Objekt erzeugt wurde um danach _Instance zurückgiebt. Stellen wir uns nun vor wir erstellen ein Objekt aus dieser Klasse mit
					
						Demo demo = Demo.Instance;
						demo.Value = 128;
						Demo demo1 = Demo.Instance;
						Console.WriteLine(demo1.Value);
						
					Wir haben and ieser Stelle versucht zwei Objekte aus der Klasse zu erzeugen, was aber nicht funktioniert, da beim erzeugen eines neuen Objekts der if Zweig umgangen wird, kein neues Objekt entsteht und nur die referenz auf das erste Objekt weitergegeben wird. Obwohl wir demo1 nie einen Wert zugewiesen haben wird der return Teil der Methode 128 enthalten und diesen wert auch in der Konsole ausgeben. Dies ist der Beweis dafür, dass es mit diesem Pattern nicht möglich ist mehr als ein Objekt zu erzeugen.
					
					Das gleiche Ergebnis könnenw ir auch erziehlen, wenn wir eine statische Klasse definieren. Hierbei ist es sogar möglich auf die beispielhafte Methode Instance zu verzichten. Zum vergleich von Singleton-Pattern und statischer Methode folgende Vor- und Nachteile:
					
						-Bei Verwendung des Singleton-Pattern wird tatsächlich ein Objekt erzeugt, das zu einem späteren Zeitpunkt vom Garbage Collector zerstört werden muss. Eine statische Klasse beschreibt hingegen kein Objekt und fällt damit auch nicht in den Aufgabenbereich des Garbage Collectors. Ein Pluspunkt der statischen Klasse.
						
						-Statische Klassen können nicht abgeleitet werden. Auch wenn und die damit im Zusammenhang stehende Vererbung thematisch erst im nächsten Kapitel beschäftigen wird, sei dieser Punkt, der generell als Nachteil bewertet werden muss, an dieser Stelle erwähnt.
						
			3.10 Namensräume (Namespaces)
				3.10.2 Die using-Direktive
				
					Wenn wir die bereits häufig genutzte Methode WriteLine() der Klasse Console nutzen möchten müssten wir eigentlich auch den Namespace mit angeben in dem sich die Klasse befindet, dieses wäre in unserem Fall System. Um eine einfache Konsolenausgabe zu erzeugen müssten wir also
					
						System.Console.WriteLine("Hallo Welt!");
						
					angeben. Diese Angabe wird als vollqualifizierter Name bezeichnet. Da Namespaces auch geschachtelt werden können, kann diese schreibweise zu unübersichtlichem Code führen. An dieser Stelle hilft uns using-Direktive. Unter Angabe von using und dann dem Namespace bzw. dem Namespace und den darunterliegenden Namespaces wird dem aktuellen Quellcode zu jeder Zeit jede enthaltene Klasse innerhalb dieser Namespaces zur Verfügung gestellt. Damit ist es möglich die Namespacebezeichner vom Code auszuschließen um den Code teilweise drastisch zu verkürzen.
					
					Es ist zu beachten, dass die Einbindung eines Namespaces durch die using-Direktive außerhalb der Klassendefinition steht.
					
				3.10.4 Vermeiden von Mehrdeutigkeiten
				
					Namespaces sind bekanntermaßen für die Sortierung von Klassen zuständig die ähnliche Funktionalitäten aufweisen. Weiterhin ist es durch Namespaces möglich Typen zu erstellen, die den gleichen Bezeichner besitzen. Hierbei kann es jedoch zu dem Problem kommen, dass mit dem Einbinden zweier Namespaces die Klassen mit dem gleichen Bezeichner besitzen dem Kompiler nicht bewusst ist, welche er nutzen soll. In diesem Fall funktioniert auch die using Direktive nicht. Um diesen Umstand zu vermeiden müssen wir die zu nutzende Klasse näher spezifizieren. Gehen wir davon aus, dass wir die Namespaces MyApplication und YourApplication haben die beide die Klasse Person definieren und weiterhin auch beide mit der using Direktive eingebunden werden. Hierzufolgendes Beispiel:
					
						using MyApplication;
						using YourApplication
						
						MyApplication.Person person = new MyApplication.Person();
						
					Wie zu sehen ist wird der zu nutzende Namespace mit angegeben um dem Problem aus dem Weg zu gehen.
					
					Weiterhin ist es möglich einen Alias zu nutzen. 
					
						using FirstPerson = MyApplication.Person;
						using SecondPerson = YourApplication.Person;
						
					Mit einem Alias ist es somit auch möglich Klassen umzubenennen:
					
						using Ausgabe = System.Console;
						
						Ausgabe.WriteLine("Hello world");
						
					
4 Vererbung, Polymorphie und Interfaces
	4.1 Die Vererbung
		4.1.1 Basisklassen und abgeleitete Klassen
		
			Nehmen wir die Beispielklasse Circle und gehen wir davon aus, dass diese als abgeschlossen gilt. Es soll also innerhalb dieser Klasse keinerlei neue Funktionalität eingebaut werden. Denno wollen wir zum Beispiel eine neue Methode schreiben, die in der Lage ist den angegebenen Kreis grafisch dazustellen. Hierzu erstellen wir eine neue Klasse namens GraphicCircle. Wir nutzen hier das Prinzip der Vererbung. Eine Klasse die ihre Funktionen an eine andere vererbt wird als Basisklasse bezeichnet. Eine Klasse die Funktionen von einer Basisklasse erbt wird als Subklasse oder abgeleitete Klasse bezeichnet. Eine abgeleitete Klasse muss nicht zwangsweise eine solche bleiben. Es kann durchaus geschehen, dass eine abgeleitete Klasse zu einer Basisklasse wird, sobald eine weitere Klasse aus dieser abgeleitet wird. Im Begriff der objektorientierten Programmierung gibt es die Einfach- und die Mehrfachvererbung. Eine einfache Vererbung findet statt, sobald eine Subklasse aus genau einer Basisklasse abgeleitet wird. Bei einer Mehrfachvererbung ist dies nicht der Fall. Um Problemen entgegenzuwirken wird in C# auf die Mehrfachvererbuntg verzichtet. Dies kommt einem Verzicht auf bestimmte Funktionalitäten gleich, der jedoch durch das Prinzip der Interfaces nahezu gleichwertig ausgeglichen wird. Weitere Informationen zum Thema Interfaces werden im weiteren Verlauf dieses Kapitels beschrieben. Als Anmerkung ist zu beachten, dass es innerhalb der .NET Umgebung nur eine wirkliche Basisklasse gibt: Object. Alle anderen .NET Klassen werden aus dieser abgeleitet oder aus einer anderen, die wiederum von Object erbt. Daraus ergibt sich eine Baumartige Struktur.
			
		4.1.2 Die Ableitung einer Klasse
		
			Um eine Klasse aus einer anderen abzuleiten nutzen wir den : Operator. Hierbei ist zu beachten, dass zuerst die abgeleitete Klasse angegeben wird und darauffolgend (getrennt durch den : Operator die Basisklasse) Um bei unserem Beispiel zu bleiben müssen wir also folgende Syntax erhalten:
			
				public class GraficCircle : Circle {
					public void Draw() {
						Console.WriteLine("Der Kreis wird gezeichnet.");
					}
				}
				
			Wie zu sehen ist erweitern wir die Klasse GraficCircle um die Methode Draw. Diese zeichnet natürlich noch keinen Kreis sondern gibt der einfachheit halber nur einen Text in der Konsole aus.
			
			Das Prinzip der Vererbung lässt sich sehr schnell udn einfach an einem Beispiel erhalten. Wenn wir nun innerhalb der Klasse GraficCircle ein Objekt erstellen und nach Aufruf desselben den Punktoperator nutzen, so wird uns ein Dropdownmenü nicht nur die Methode Draw innerhalb dieser Klasse angezeigt, sondern auch alle als public deklarierten Methoden und Eigenschaften der Klasse Circle. Dies lässt uns darauf schließen, dass eine Objekt des Typs GraficCirlce automatisch auch ein Objekt des Typs Circle ist da es dessen gesamte (als publich deklarierten) Funktionalitäten erbt.
			
		4.1.3 Klassen, die nicht abgeleitet werden können
		
			Klassen die als sealed definiert sind
			
				In einigen fällen macht es sinn einer Klasse die Fähigkeit zu nehmen als Basisklasse zu fungieren, da es entweder keinen Sinn macht dieses zu tun oder strikt unterbunden werden soll, da zum Beispiel die errechneten Werte als Endergebnisse gelten sollen.
				
				Um sicherzustellen, dass eine Klasse nicht weiter vererbt werden kann wird die Klassendefinition um den Modifizierer sealed ergänzt:
				
					public sealed class GraficCirlce {
						[...]
					}
					
			Statische Klassen und Vererbung
			
				Neben sealed Klassen können auch aus statischen Klassen keine anderen abgeleitet werden. Des Weiteren kann eine statische Klasse keine andere Basisklasse besitzen als die Klasse Object.
				
		4.1.4 Konstruktoren in abgeleiteten Klassen
		
			Beim Erzeugen eines Objekts einer abgeleiteten Klasse gelten die gleichen Regeln wie bei dem einer Basisklasse:
			
				Es wird generell ein Konstruktor aufgerufen.
				Der Subklassenkonstruktor darf überladen werden.
				
			Da Konstruktoren nicht von der Basisklasse in die abgeleitete Klasse vererbt werden ist es notwendig alle benötigten Konstruktoren zu erstellen. Wollen wir Werte nutzen die in der Basisklasse vorhanden sind aber als private Member deklariert sind bekommen wir ein Problem. Auch wenn ein Objekt aus der abgeleiteten Klasse gleichzeitig auch ein Objekt der Basisklasse ist, kann man von dieser aus trozzdem nicht auf private Member zugreifen.
			
		4.1.5 Der Zugriffsmodifizierer preotected
		
			Als protected definierte Member verhalten sich ähnlich wie private deklarierte. Man kann zwar von außerhalb nicht darauf zugreifen, jedoch wird sichergestellt, dass aus abgeleiteten Klassen direkt darauf zugegriffen werden kann. 
			
			
		4.1.6 Konstruktorverkettung in der Vererbung
		
			Wenn wir den bereits erwähnten Counter für die instanziierten Objekte implementiert haben und nun, darauf rücksicht nehmend, dass ein Objekt der Subklasse auch immer ein Objekt der Basisklasse ist, diesen um 1 erhöhen, sobald ein Objekt aus der Subklasse instanziiert wird kommen wir zum Ergebnis 2, wenn wir nur ein Objekt Instanziieren. Dies ist dem Fakt geschuldet, dass beim instanziieren eines Objekts aus der Subklasse (und dem damit verbundenen Ausführen des Konstruktors der Subklasse) auch immer die Konstruktoren der Basisklasse aufgerufen werden. Dies führt dazu, dass wir den Counter zweimal erhöhen und damit jedesmal ein Falsches Ergebnis erhalten werden, sobald wir ein Objekt aus der Subklasse erzeugen. Dies wird als Kontruktorverkettung bezeichnet. Zu beachten ist hierbei, dass standartmäßig immer der Parameterlose Konstruktor aufgerufen wird. Hieraus ergibt sich ein großes Problem für Klassen mit selbst implementierten Konstruktoren. Wie wir wissen besteht immer der impliziete Parameterlose Konstruktor. Dies ist jedoch nur solange der Fall bis wir einen eigenen Konstruktor erstellen. Da durch die Konstruktorverkettung jedoch immer der parameterlose Konstuktor aufgerufen wird (welcher im Fall selbstimplementierter Parameterbehafteter Konstruktoren überschrieben wird) kommt es in diesem Fall zu einem Kompilierfehler, wenn wir nicht explizit einen Parameterlosen Konstruktor implementieren.
			
			
			Die Konstruktorverkettung mit base steuern
			
				Wie bereits erwähnt liegt der Fehler hier daran, dass wir den Counter zweimal aufrufen. Einmal in den Konstruktoren der Basisklasse und einmal in den Konstruktoren der Subklasse. Um dieses Problem zu beheben macht es Sinn beim erzeugen eines Objekts aus der Subklasse die Konstruktoren der Basisklasse aufzurufen, da diese die gleiche Funktionalität aufweisen wie die der abgeleiteten Klasse. Dies ist mit dem Schlüsselwort base möglich. Dieses kann wie das Schlüsselwort this in Kontruktoren verwendet werden. Um dies zu veranschaulichen gehen wir zu dem bereits bekannten Bespiel der Circle bzw. GraficCircle Klasse:
				
					public GraficCircle : base(0, 0, 0) { }
					
					public GraficCircle (int radius) : base(radius, 0, 0) { }
					
					public GraficCircle(int radius, double x, double y) : base(radius, x , y) { }
					
				Wie hier zu sehen ist wird mit dem Schlüsselwort der Kontruktor der direkten Basisklasse aufgerufen und diesem die eventuell vorhandenen Parameter übergeben. In diesem Beispiel wird immer der dreifach parametrisierte Parameter aufgerufen. Dies macht in unserem Fall auch Sinn, da wir diesem die eigentliche Funktionalität zugewiesen haben.
				
			Der Zugriff auf die Member der Basisklasse mit base
			
				Das Schlüsselwort base kann auch genutzt werden um auf Member der Basisklasse zuzugreifen, sofern diese nicht privat deklariert sind. Hierbei ist zu beachten, dass auch Methoden einer Basisklasse angesprochen werden können die wiederum zu einer Basisklasse darüber gehören. Hierzu folgendes Beispiel:
				
					class BaseClass {
						public void DoSomething() {
							Console.WriteLine("Test");
						}
					}
					
					class SubClass1 : BaseClass {}
					
					clas SubClass2 : SubClass1 {
						public void Basetest() {
							base.DoSomething();
						}
					}
				
				Ein doppelter Aufruf von base ist nicht gestattet, so wird
				
					base.base.DoSomething();
					
				nicht funktionieren. Es ist weiterhin zu beachten, dass statische Methoden nicht mit base aufgerufen werden können.
				
		
	4.2 Das Problem geerbter Methoden
		
		Gehen wir einmal davon aus wir haben eine Klasse Luftfahrzeug. Diese beerbt die beiden Klassen Flugzeug und Hubschrauber. Da jedes dieser Luftfahrzeuge sowohl einen Hersteller als auch ein Baujahr hat, werden diese in der Basisklasse definiert. Die Spannweite hingegen wird in der Klasse Flugzeug implementiert, Rotordurchmesser hingegen in der Klasse Hubschrauber.
		Nun wollen wir die Methode Starten() implementieren und hier treffen wir auf ein Problem. Beide Luftfahrzeuge können zwar starten, sie tun dies aber auf vollkommen unterschiedliche Art und Weise. Nichtdestotrotz wollen wir diese Methode durch die Basisklasse bereitstellen. Hierzu sind uns drei möglichkeiten gegeben:
		
			- Wir verdecken die geerbten Methoden der Basisklasse in den abgeleiteten Klassen mit dem moddifizierer new
			- Wir stellen in der Basisklasse eine abstrakte Methode bereit, die in der jeweiligen Subklasse überschrieben werden muss
			- Wir stellen in der Basisklasse eine virtuelle Methode bereit
			
		4.2.1 Geerbte Methoden mit new verdecken
			
			Es ist möglich eine geerbte, bereits implementierte Methode neu zu definieren indem wir den Modifizierer new nutzen. Mit
			
				public class Flugzeug : Luftfahrzeug {
					public new void Starten() {
						Console.WriteLine("Das Flugzeug startet.");
					}
				}
			
			Sind wir in der Lage die Methode die eigentlich in der Basisklasse defniert wurde zu überschreiben und unabhänig von dieser die neue nutzen. Man spricht in diesem Fall vom verdecken oder ausblenden der geerbten Methode. Als verdeckt bzw. ausgeblendet gilt eine geerbte Basisklassenmethode nur dann wenn diese
			
				- den gleichen Namen wie eine Methode der Basisklasse besitzt,
				- über die gleiche Parameterliste verfügt
				
			und dennoch komplett in der Subklasse implementiert ist.
				
				Statische Member überdecken
					
					Neben Instanzmethoden können auch Eigenschaftsmethoden und statische Komponente einer Basisklasse verdecken. Die im späteren Verlauf erklärten Modifizierer abstract, virtual und override sind im Zusammenhang mit statischen Membern nicht erlaubt
					
		4.2.2 Abstrakte Methoden
		
			Das Prolem beim verdecken von Basisklassenmethoden liegt auf der Hand. Wird vergessen eine Basisklassenmethode in einer Subklasse zu verdecken, wird die Subklasse immer die Methode der Basisklasse aufrufen was evtl. zu Fehlern führen kann. 
			
			Hier hilft uns das Model der abstrakten Methoden weiter. An und für sich ist es nicht notwendig die Methode Starten() in der Basisklasse zu implementieren. Sie wurde dort nur definiert, damit sie jeder Subklasse zu verfügung steht. Da diese Methode jedoch von jeder Subklasse Typspezifisch neu implementiert werden muss, lassen wir den gesamten Anweisungsblock einfach weg und erweitern die Methode um den Modifizierer abstract.
			
			Dieser zwingt jede Subklasse die Methode neu zu implementieren sofern die Methode genutzt werden soll. Die Methode Starten() müsste als abstrakte Methode in der Basisklasse also wie folgt aussehen:
			
				public abstract void Starten();
				
			Es ist zu beachten, das eine Klasse die mindestens eine abstrakte Methode enthält selbst abstrakt ist und als solche angegeben werden muss. Anhand des Beispiels der Klasse Luftfahrzeug erhalten wir also:
			
				public abstract class Luftfahrzeug {
					public abstract void Starten();
					[...]
				}
			
			Eine abstrakte Klasse kann auch Methoden enthalten die nicht abstrakt sind. Wichtig ist weiterhin, dass eine abstrakte Klasse nicht instanziiert werden kann.
			Weiterhin ist zu beachten, dass eine Subklasse alle Member die abstrakt sind neu implementieren muss. Tut sie dies nicht muss sie zwingendermaßen auch als abstrakte Klasse gekennzeichnet werden.
			Wie bereits erwähnt muss jede Klasse die ein abstraktes Member besitzt selber abstrakt sein, jedoch kann eine Klasse als abstrakt definiert sein ohne ein abstract Member zu besitzen. Damit wird vermieden, dass diese Klasse instanziiert werden kann und erzwingt somit, dass diese Klasse abgeleitet werden muss.
			
			Abstrakte Methoden überschreiben
			
				Um eine abstrakte Methode zu überschreiben muss diese den Modifizierer override aufweisen. 
				
		4.2.3 Virtuelle Methoden
		
			Die dritte angesprochene Möglichkeit ist die Implementierung einer virtuellen Methode. Hierbei wird in der Basisklasse die Methode komplett implementiert. In der Subklasse besteht dann eine der drei folgenden Möglichkeiten:
			
				- Die abgeleitete Klasse erbt die Methode von der Basisklasse ohne diese weiter zu bearbeiten
				- Die abgeleitete Klasse verdeckt die Methode mit dem Modifizierer new und
				- Die abgeleitete Klasse überschreibt die Methode der Basisklasse mit dem Modifizierer override
				
			Um den unterschied zwischen den beiden zuletzt genannten Möglichkeiten zuerläutern ist es sinnvoll sich dem dritten elementaren Konzept der Objektorientierung zu widmen: der Polymophie. Bevor wir uns diesem Punkt zuwenden sollten wir uns jedoch mit der Typumwandlung in einer Vererbungshierarchie beschäftigen.
			
	4.3 Typumwandlung und Typuntersuchung von Objektvariablen
	
		4.3.1 Die implizite Typumwandlung von Objektreferenzen
		
			Während die Klasse Luftfahrzeug die allgemeinen Eigenschaften eines solchen beschreibt, sind die Klassen Flugzeug und Hubschrauber als Subklassen dafür zuständig spezifischere Eigenschaften aufzuzeigen.
			Betrachten wir nun einen Ausschnitt der Klassenhierarchie, nämlich die beiden Klassen Flugzeug und Luftfahrzeug. Gehen wir von der realen Welt aus so ist jedes Flugzeug (also jedes Objekt, dass aus der Klasse Luftfahrzeug instanziiert wurde) gleichzeitig auch ein Luftfahrzeug. Dies gilt jedoch nicht umgekehrt, denn ein Luftfahrzeug kann auch zum Beispiel ein Hubschrauber sein. Ist diese Situation gegeben spricht man von einer "Ist-ein(e)-Beziehung". 
			
			Die Vererbung hat Konsequenzen, denn aufgrund dieser Beziehung kann man die Referenz eines Subklassenobjekts einer Basisklassenreferenz zuweisen:
			
				Flugzeug flg = new Flugzeug();
				Luftfahrzeug lfzg = flg;
				
			Stehen zwei Klassen in einer Vererbungsbeziehung, kann eine Referenz vom typ der abgeleiteten Klasse der Referenz vom Typ einer Basisklasse zugewiesen werden:
			
				Basisklassenreferenz = Subklassenreferenz
				
			Hierbei ist zu beachten, dass immer implizit konvertiert wird.
			
			Die beiden Variablen flg und lfzg referenzieren den selben Speicherbereich. Hierbei ist jedoch zu beachten, dass die Laufzeitumgebung lfzg nur als Objekt der Klasse Luftfahrzeug ansieht und nicht als Flugzeug. Damit hat lfzg auch keinen Zugriff auf die Member der Subklasse die diese ausmachen.
			
			Bei einer Zuweisung einer Subklassenreferenz zu einer Basisklassenreferenz müssen alle Member der links vom Zuweisungsoperator angegebenen Referenz einen konkreten Bezug zu einem Member der rechts vom Zuweisungsoperator stehenden Referenz haben. Faktisch bedeutet das, dass ein Flugzeug immer einen Hersteller sowie ein Baujahr hat, da dies durch die Basisklasse angegeben ist.
			
			Gehen wir von folgender Methodendefinition aus:
			
				public void DoSomething(Luftfahrzeug lfzg) {
					[...]
				}
		
			Wie zu sehen ist verlangt die Methode DoSomething() einen Parameter vom Typ Luftfahrzeug. In diesem Fall können wir uns den Fakt zunutze machen, dass ein Objekt der Subklasse Flugzeug auch immer ein Objekt der Klasse Luftfahrzeug ist. So ist
			
				Flugzeug flg = new Flugzeug();
				@object.DoSomething(flg);
				
			durchaus eine valide Parameterübergabe, da das Objekt flg alle Member enthällt, die durch die Methode verlangt werden. Faktisch kann also jedes Objekt der Luftfahrzeug Klasse sowie deren Subklassen übergeben werden.
			
			Da diese Methode in der Luftfahrzeug Klasse definiert ist, steht diese sowohl der Flugzeug Klasse als auch der Hubschrauber Klasse zur Verfügung was uns die doppelte implementierung erspart. Weiterhin gibt uns diese Typumwandlung die Möglichkeit weitere Subklassen von Luftfahrzeug zu erzeugen und trotzdem die Funktionalität der Methode zu gewährleisten da, wie mehrfach erwähnt, ein Objekt einer Subklasse auch immer ein Objekt der Basisklasse ist.
			
		4.3.2 Die explizite Typumwandlung von Objektreferenzen
		
			Es ist möglich die Basisklassenreferenz explizit in eine Subklassenreferenz umzuwandeln sofern diese in einer Vererbungsbeziehung stehen. Hierbei ist zu beachten, dass der Zieldatentyp in runden Klammern geschrieben wird:
			
				Subklassenreferenz = (Zieldatentyp) Basisklassenreferenz
				
			Eine horizontale Typkonvertierung (in usnerem Beispiel also von Flugzeug in Hubschrauber) ist nicht gestattet.
			
		4.3.3 Typumwandlung mit dem is Operator
		
			Es kann nötig sein ein typspezifisches Member mit einer Basisklassenreferenz aufzurufen. Hierzu bietet sich der is Operator an. Sehen wir uns hierzu folgendes Codefragment an:
			
			
				public void DoSomething(Luftfahrzeug lfzg) {
					if(lfzg != null) {
						if(lftzg is Flugzeug) {
							Cojnsole.WriteLine("Spannweite: ", ((Flugzeug)lfzg).Spannweite);
						}
					}
					else if(lfzg is Hubschrauber) {
						Console.WriteLine(Rotor: ", ((Hubschrauber)lfzg).Rotor);
					}
					else {
						Console.WriteLine("Unbekannter Typ");
					}
				}
			
			Wie zu erkennen ist, prüfen wir in disem Codefragment, ob es möglich ist, die Referenz lfzg in den Typ Flugzeug bzw. Hubschrauber zu konvertieren. Zu beachten ist hierbei, dass wir vorher auf null prüfen, da diese Methode auch mit einer null Referenz aufgerufen werden könnte. Weiterhin fällt die Umklammerung der Konvertierung auf:
			
				((Hubschrauber)lfzg).Rotor
				
			Dies ist vonnöten, da der Punkt Operator stärker bindet als die Konvertierung. Mit den Klammern sorgen wir dafür, dass erst konvertiert wird und danach die nötige Methode aufgerufen wird.
			
		4.3.4 Typumwandlung mit dem as Operator
		
			Der as Operator verhällt sich ähnlich wie die explizite konvertierung im zuvor behandelten Punkt. So führt
			
				Flugzeug flg = lfzg as Flugzeug;
				
			zum gleichen Ergebnis wie die vorher genannte Konvertierung
			
				Flugzeug flg = (Flugzeug)lfzg;
				
			Der Unterschied zwischen dem is- und dem as-Operator ist jedoch, dass der is-Operator bei einer nicht durchführbaren Konvertierung eine Exception wirft, während der as-Operator den Wert null zurückgibt, wenn eine Konvertierung nicht möglich ist. Damit eignet sich der as-Operator sehr gut für if Abfragen, da wir damit auf valide Konvertierungen
			
				if(lfzg as Flugzeug != null)
				
			durchführen können.
			
			Zusätzlich ist zu erwähnen, dass der as-Operator nur auf Referenztypen genutzt werden kann.
			
	4.4 Polymophie
	
		Um im weiteren Verlauf dieses Kapitels ein Verständnis aufzubauen sei folgender Code gegeben:
		
			static void Main(string[] args) {
				Luftfahrzeug[] arr = new Luftfahrzeug[4];
				arr[0] = new Flugzeug();
				arr[1] = new Hubschrauber();
				arr[2] = new Hubschrauber();
				arr[3] = new Flugzeug();
				
				foreach(Luftfahrzeug temp in arr) {
					temp.Starten();
				}
				Console.ReadLine();
			}
		
		Wie unschwer zu erkennen ist wird innerhalb der Main Methode ein Array mit dem Bezeichner arr vom Typ Luftfahrzeug erstellt. Dieses wird mit den Referenzen auf die Subklassen Flugzeug und Hubschrauber gefüllt. Danach wird mit einer foreach Schleife auf jedes Element des Arrays die Funktion Starten aufgeführt. Zu beachten ist hierbei, dass die temporäre Schleifenvariable temp vom Typ der Basisklasse ist, also Luftfahrzeug.
		
		4.4.1 Die klassische Methodenimplementierung
		
			An dieser stelle wollen wir die Klasse Methodenimplementierung in der Basisklasse testen. Die beiden abgeleiteten Klassen sollen die geerbte Methode Starten() mit dem Modifizierer new überdecken:
			
				public class Luftfahrzeug {
					public void Starten() {
					Console.WriteLine("Das Luftfahrzeug startet.");
					}
				}
				
				public class Flugzeug : Luftfahrzeug {
					public new void Starten() {
						Console.WriteLine("Das Flugzeug startet.");
					}
				}
				
			Wenn wir die oben angegebene Anwendung ausführen so kommen wir zu dem Ergebnis, dass vier mal "Das Luftfahrzeug startet" ausgegeben wird. Dies ist dem Fakt geschuldet, dass der Methodenaufruf an die Basisklasse statisch gebunden wird. Statisches Binden bedeutet, dass zur kompilierzeit die Operation bereits festgelegt wird. Der Compiler stellt fest von welchem Typ das Objekt ist, auf dem die Methode aufgerufen wird, und erzeugt den entsprechenden Code. Statisches Binden führt also dazu, dass die Methode der Basisklasse aufgerufen wird, obwohl die neu implementierte Methode genutzt werden sollte.
			
		4.4.2 Abstrakte Methoden
		
			Nun nutzen wir die Möglichkeit die Methode als abstrakte Methode zu implementieren. Hierzu nutzen wir das Schlüsselwort abstract in der Methodendefinition der Basisklasse und überschreiben diese in der Subklasse mit dem schlüsselwort overwrite. Hierbei ist zu beachten, dass die Basisklasse ebenfalls als abstract deklariert werden muss. Hierzu folgendes Beispiel:
			
				public abstract class Luftfahrzeug {
					public abstract void Starten();
				}
				
				public abstract class Flugzeug : Luftfahrzeug {
					public override void Starten() {
						Console.WriteLine("Das Flugzeug startet.");
					}
				}
			
			Mit dieser Implementierung ist gewährleistet, dass die Bindung dynamisch und damit zur Laufzeit stattfindet. Dies resultiert, bei einer neuen Asuführung der Anwendung in einem vollkommen anderen Resultat. In diesem Fall wird nämlich jeweils die richtige (typspizifische) Methode aufgerufen.

			Die Fähigkeit auf einer Basisklassenreferenz eine Typspezifische Methode aufzurufen wird als Polymorphie bezeichnet. Polymorphie bildet neben der Datenkapselung und der Vererbung die dritte Säule der Objektorientierung. Besagte Polymorphie bezeichnet ein Konzept der Objektorientierung, das besagt, dass Objekte bei gleichen Methodenaufrufen unterdschiedlich reagieren können.
			
		4.4.3 Virtuelle Methoden
		
			Virtuelle Methoden sind als Angebot der Basisklasse zu betrachten. Der jeweiligen Subklasse ist damit die Möglichkeit gegeben die als virtuell deklatierte Methode entweder einfach zu erben und genau so zu nutzen, diese mit dem Schlüsselwort override polymorph zu überschreiben oder diese nicht polymorph unter Zuhilfename der Schlüsselworts new zu überdecken. Es ist zu beachten, dass die implementierung der Methoden in der jeweiligen Subklasse der in den vorherig beschriebenen Beispielen entspricht, weshalb an dieser Stelle nicht nochmal darauf eingegangen wird.
			
			
			Weitergehende Betrachtungen
			
				Es ist durchaus möglich, dass innerhalb einer Vererbungskette ein gemischtes Verhalten von Überdeckung bzw. Überschreibung einer Methode stattfinden kann. Hierzu sehen wir und folgendes Beispiel an:
				
					public class Luftfahrzeug {
						public virtual void Starten() { }
					}
					
					public class Flugzeug : Luftfahrzeug {
						public override void Starten() {
							[...]
						}
					}
					
					public class Segelflugzeug : Flugzeug {
						public new void Starten () {
							[...]
						}
					}
					
				Gehen wir nun davon aus, dass wir mit
				
					Luftfahrzeug lfzg = new Segelflugzeug();
					
				ein Objekt initialisieren und darauf die Methode Starten() ausführen, so wird in diesem Fall die Methode in der Klasse Flugzeug aufgerufen, da diese die Methode Polymorph überschreibt und diese in Segelflugzeug nur mit new überdeckt wird. Es ist zu beachten, dass eine mit zu überdeckte Methode in einer abgeleiteten Klasse nicht mehr mit dem Schüsselwort override überschrieben werden kann. Ein einmal verloren gegangenes polymorphes Verhalten kann nicht wieder zurückerlangt werden.
				
	4.5 Weitere Gesichtspunkte der Vererbung
	
		4.5.1 Versiegelte Methoden
		
			Standartmäßig kann jede Klasse abgeleitet werden. Möchte man dieses Verhalten unterbinden ist es notwendig diese mit dem Schüsselwort sealed zu versiegeln. Ähnlich verhällt es sich bei Methoden. 
			
				class Flugzeug : Luftfahrzeug {
					public sealed override void Starten() {
						Console.WriteLine{"Das Flugzeug startet"};
					}
				}
				
			Eine von Flugzeug abgeleitete Klasse erbt zwar die Methode Starten(), kann diese aber nicht mehr mit override überschreiben. Die Überdeckung mit new ist jedoch immernoch gegeben um eine typspezifische Implementierung der Methode zu gewährleisten. Es ist zu beachten, dass eine als sealed definierte Methode immer auch den Modifizierer override aufweisen muss und weiterhin weder alleine stehen kann noch in Zusammnhang mit dem Schlüsselwort new genutzt werden kann. Dies setzt logischerweise vorraus, dass die Methode in der Basisklasse als vitual definiert wurde.
			
		4.5.2 Überladung einer Basisklassenmethode
		
			Wie uns bereits bekannt ist spricht man von der Überladung einer Methode innerhalb einer Klasse, wenn sich diese nur in der Anzahl der Parameter die an sie übergeben wird unterscheidet. Der gleiche Begriff hat sich geprägt, wenn eine geerbte Methode in der Subklasse nach den Regeln der Methodenüberladung ergänzt werden muss.
			
			Ändern wir nun also nochmals die Methode Starten() der Klasse Flugzeug und überladen diese:

				public class Flugzeug : Luftfahrzeug {
					public void Starten(double distance) {
						[...]
					}
				}
				
			Wenn wir nun ein Objekt flg vom Typ Flugzeug erzeugen und
			
				flg.Starten();
				flg.Starten(300);
				
			ausführen, so ist dies nicht nur gestattet, sondern führt auchnoch dazu, dass einmal die Methode der Basisklasse und einmal die der Subklasse aufgerufen wird.
			
		4.5.3 Statische Member und Vererbung
		
			Statische Member werden an die abgeleitete Klasse vererbt. Statische Methoden können innerhalb der Basisklasse oder unter Angabe der Subklasse auch dort genutzt werden.
			
			Gehen wir also von der Methode Bigger(Circle kreis1, Circle kreis2) der Klasse Circle aus, die die Göße zweier Kreisobjekte vergleicht, so funktioniert sowohl der Aufruf
			
				Circle.Bigger(kreis1, kreis2);
				
			als auch
			
				GraphicCircle.Bigger(kreis1, kreis2);
				
			wobei die übergebenen Objekte wie gesagt vom Typ Circle sind.
			
			Wie bereits gesagt ist die Definition einer statischen Methode mit den Schlüsselwörtern override, virtual oder abstract nicht zulässig, jedoch kann man mit new eine typspezifische Anpassung der statischen Methode vornehmen.
			
	4.7 Eingebettete Klassen (Nested Classes)
	
		Wird eine Klasse innerhalb einer anderen definiert spricht man von eingebetteten Klassen (Nested class). Dies wird durchgeführt, wenn man eine enge Beziehung zwischen zwei Klassen oder allgemein gesprochen zwei Typen ausdrücken möchte. Eine andere typische Nutzung ist, dass man eine Klasse vor dem Zugriff von außen  schützen will, da diese nur innerhalb der sie umgebenen Klasse Sinn macht. Wenn wir die innere Klasse als public deklarieren ist es uns gestattet ein Objekt dieser inneren Klasse aus der äußeren heraus zu instanziieren. Deklarieren wir die innere Klasse jedoch als private kann man ein Objekt nurnoch innerhalb der inneren Klasse instanziieren und somit haben wir eine abgeschottete Klasse geschaffen. Da dieses Verfahren äußerst selten angewandt wird, soll an dieser Stelle jedoch außer der gegebenen Erwähnung der Möglichkeit nicht weiter darauf eingegangen werden.
		
	4.8 Interfaces (Schnittstellen)
	
		4.8.1 Einführung in die Schnittstellen
		
			Um eine Interface zu verstehen ist es wichtig sich nochmals klarzumachen, was eine Klasse und was ein Objekt ist. Eine Klasse ist eine Art Bauplan und beschreibt die Fähigkeiten eines Objektes während ein Objekt die bereitgestellten Methoden, Ereignisse etc. nutzt um damit faktisch etwas durchzuführen. Kurz gesagt ist eine Klasse also für das bereitstellen von Eigenschaften und Methoden gedacht während ein Objekt aus Daten besteht und diese manipulieren kann. Ein Interface beschreibt niemals Daten und bildet damit das andere Extrem. Faktisch ist ein Interface nicht weiter als ein klassenähnliches Konstrukt, welches ausschließlich aus abstrakten, sprich nicht implementierten Methoden besteht. Damit stellt es diverse Dinge zur Verfügung, die jedoch noch innerhalb der abgeleiteten Klasse implementiert werden muss. Aus diesem Grund spricht man bei Interfaces im Bezug auf die Vererbung auch nicht von Ableitung sondern von Implementierung. 
			
		4.8.2 Die Schnittstellendefinition
		
			Schnittstellen können 
			
				-Methoden
				-Eigenschaften
				-Ereignisse und
				-Indexer
				
			vorschreiben. Vorschreiben in dem Fall, da wir wissen, das abstrakte Member von der ableitenden / implementierenden Klasse implementiert werden müssen da sie sonst selbst als abstrakt gekennzeichnet werden müssen.
			
			Schnittstellen enthalten selbst keine Codeimplementierungen, sondern nur abstrakte Definitionen. Hierzu folgendes Beispiel:
			
				public interface ICopy {
					string Caption {get; set; };
					void Copy();
				}
				
			Wie zu erkennen ist, sieht die Definition eines Interface dem einer Klasse sehr ähnlich. Wir nutzen jedoch anstatt des Schlüsselworts class das Schlüsselwort interface. Es ist zu beachten, dass ein Interface nur als public oder als internal deklariert werden kann wobei internal der standart ist, weshalb interfaces die keinen Zugriffsmodifizierer besitzen immer internal sind. Weiterhin ist zu beachten, dass die Member eines Interface auf das Schlüsselwort abstract verzichten können. Eine weitere zu beachtende Konvention ist, dass ein Interfacebezeichner stehts mit einem großen "I" beginnt.
		
			
		4.8.3 Die Schnittstellenimplementierung
		
			Analog zur Ableitung, also der Vererbung einer Klasse spricht man bei einer Schnittstelle von ihrer Implementierung. Wie bei abstrakten Klassen muss auch jedes Member eines Interfaces implementiert werden, wenn man nicht möchte, dass die angegebene Klasse ebenfalls eine abtrakte sein soll. Ein Interface wird hinter den Klassenbezeichner geschrieben, der dieses implementieren soll, getrennt mit einem Doppelpunkt. An und für sich kann man in die im Interface enthaltenen Methoden jeden Code schreiben den man möchte. Dies würde jedoch den Sinn eines Interface verfehlen. Man sollte sich also strikt an die Dokumentation eines Interface halten um herauszufinden wofür die jeweiligen Member zuständig sein sollen und wie diese zu implementieren sind. Im Umkehrschluss ist ein Interface ohne Dokumentation vollkommen wertlos.
			
			
		
			
			
			
			
			
			
			